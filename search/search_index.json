{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"AlgoTree","text":"<p>A powerful, modern tree manipulation library for Python with an immutable-by-default API.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Immutable by Default: All operations return new objects, never mutate</li> <li>Composable: Small functions that combine with <code>&gt;&gt;</code>, <code>|</code>, <code>&amp;</code> operators</li> <li>Type Safe: Full type hints for IDE support</li> <li>Multiple Formats: Parse trees from visual, indent, or S-expression formats</li> <li>Rich Export: JSON, GraphViz, Mermaid, HTML, and more</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from AlgoTree import Node, parse_tree, pretty_tree\n\n# Create trees with constructor\ntree = Node(\"root\",\n    Node(\"src\", Node(\"main.py\"), Node(\"utils.py\")),\n    Node(\"docs\", Node(\"README.md\"))\n)\n\n# Or parse from text\ntree = parse_tree(\"\"\"\nroot\n\u251c\u2500\u2500 src\n\u2502   \u251c\u2500\u2500 main.py\n\u2502   \u2514\u2500\u2500 utils.py\n\u2514\u2500\u2500 docs\n    \u2514\u2500\u2500 README.md\n\"\"\")\n\n# Visualize\nprint(pretty_tree(tree))\n\n# Transform (immutably)\nfiltered = tree.filter(lambda n: not n.name.startswith(\".\"))\nwith_attrs = tree.map(lambda n: n.with_attrs(visited=True))\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install AlgoTree\n</code></pre>"},{"location":"#whats-new-in-v20","title":"What's New in v2.0","text":"<ul> <li>Immutable Nodes: All operations return new nodes; originals are never modified</li> <li>Composable Selectors: Pattern matching with <code>&amp;</code>, <code>|</code>, <code>~</code> operators</li> <li>Pipeline Transformers: Chain transformations with <code>&gt;&gt;</code> or <code>|</code></li> <li>DSL Parsing: Parse trees from visual, indent, or S-expression formats</li> <li>AlgoGraph Interop: Convert trees to/from graph representations</li> <li>Type Safety: Full type hints for IDE support</li> </ul>"},{"location":"#author","title":"Author","text":"<p>Alexander Towell (Alex Towell) Southern Illinois University Edwardsville (SIUE) queelius@gmail.com | GitHub</p>"},{"location":"#license","title":"License","text":"<p>MIT License - see LICENSE for details.</p>"},{"location":"api/","title":"API Reference","text":"<p>Complete API documentation for AlgoTree.</p>"},{"location":"api/#core-components","title":"Core Components","text":"<ul> <li>Node - Immutable tree nodes</li> <li>Tree - Tree wrapper with functional operations</li> <li>Selectors - Pattern matching for nodes</li> <li>Transformers - Composable tree operations</li> </ul>"},{"location":"api/#quick-import-reference","title":"Quick Import Reference","text":"<pre><code>from AlgoTree import (\n    # Core\n    Node, node, Tree,\n\n    # Selectors\n    name, attrs, type_, predicate,\n    depth, leaf, root, any_, none,\n\n    # Transformers\n    map_, filter_, prune, graft,\n    flatten, normalize, annotate,\n    reduce_, fold, extract, to_dict, to_paths,\n\n    # Builders\n    TreeBuilder, FluentTree, TreeContext, QuickBuilder,\n    tree, branch, leaf_node,\n\n    # DSL\n    parse_tree, TreeDSL,\n\n    # Export\n    export_tree, save_tree, pretty_tree,\n\n    # Interop\n    tree_to_graph, graph_to_tree,\n    node_to_flat_dict, flat_dict_to_node,\n)\n</code></pre>"},{"location":"api/node/","title":"Node API","text":""},{"location":"api/node/#AlgoTree.node.Node","title":"<code>AlgoTree.node.Node</code>","text":"<p>Immutable tree node with functional operations.</p> <p>All operations return new trees, preserving immutability. Uses structural sharing for efficiency.</p>"},{"location":"api/node/#AlgoTree.node.Node.name","title":"<code>name</code>  <code>property</code>","text":"<p>Node name (immutable).</p>"},{"location":"api/node/#AlgoTree.node.Node.children","title":"<code>children</code>  <code>property</code>","text":"<p>Children nodes (immutable tuple).</p>"},{"location":"api/node/#AlgoTree.node.Node.attrs","title":"<code>attrs</code>  <code>property</code>","text":"<p>Node attributes (returns copy to prevent mutation).</p>"},{"location":"api/node/#AlgoTree.node.Node.is_leaf","title":"<code>is_leaf</code>  <code>property</code>","text":"<p>Check if this is leaf node.</p>"},{"location":"api/node/#AlgoTree.node.Node.is_root","title":"<code>is_root</code>  <code>property</code>","text":"<p>Check if this is root node.</p>"},{"location":"api/node/#AlgoTree.node.Node.size","title":"<code>size</code>  <code>property</code>","text":"<p>Get total number of nodes in subtree.</p>"},{"location":"api/node/#AlgoTree.node.Node.height","title":"<code>height</code>  <code>property</code>","text":"<p>Get height of subtree rooted at this node.</p>"},{"location":"api/node/#AlgoTree.node.Node.depth","title":"<code>depth</code>  <code>property</code>","text":"<p>Get depth from root (root has depth 0).</p>"},{"location":"api/node/#AlgoTree.node.Node.path","title":"<code>path</code>  <code>property</code>","text":"<p>Get path from root as string.</p>"},{"location":"api/node/#AlgoTree.node.Node.parent","title":"<code>parent</code>  <code>property</code>","text":"<p>Parent node (weak reference).</p>"},{"location":"api/node/#AlgoTree.node.Node.__init__","title":"<code>__init__(name, *children, attrs=None, parent=None)</code>","text":"<p>Create an immutable node.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Node name/identifier</p> required <code>*children</code> <code>Node</code> <p>Child nodes</p> <code>()</code> <code>attrs</code> <code>Optional[Dict[str, Any]]</code> <p>Node attributes/payload</p> <code>None</code> <code>parent</code> <code>Optional[Node]</code> <p>Parent node (internal use - managed automatically)</p> <code>None</code>"},{"location":"api/node/#AlgoTree.node.Node.get","title":"<code>get(key, default=None)</code>","text":"<p>Get attribute with default.</p>"},{"location":"api/node/#AlgoTree.node.Node.with_name","title":"<code>with_name(name)</code>","text":"<p>Return new node with different name.</p>"},{"location":"api/node/#AlgoTree.node.Node.with_attrs","title":"<code>with_attrs(**attrs)</code>","text":"<p>Return new node with updated attributes.</p>"},{"location":"api/node/#AlgoTree.node.Node.with_child","title":"<code>with_child(child, **attrs)</code>","text":"<p>Return new node with child added.</p>"},{"location":"api/node/#AlgoTree.node.Node.with_children","title":"<code>with_children(*children)</code>","text":"<p>Return new node with children replaced.</p>"},{"location":"api/node/#AlgoTree.node.Node.without_child","title":"<code>without_child(child)</code>","text":"<p>Return new node with child removed.</p>"},{"location":"api/node/#AlgoTree.node.Node.walk","title":"<code>walk(order='preorder')</code>","text":"<p>Walk tree in specified order.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>str</code> <p>'preorder', 'postorder', or 'levelorder'</p> <code>'preorder'</code>"},{"location":"api/node/#AlgoTree.node.Node.leaves","title":"<code>leaves()</code>","text":"<p>Iterate over all leaf nodes.</p>"},{"location":"api/node/#AlgoTree.node.Node.descendants","title":"<code>descendants()</code>","text":"<p>Iterate over all descendants (not including self).</p>"},{"location":"api/node/#AlgoTree.node.Node.ancestors","title":"<code>ancestors(include_self=False)</code>","text":"<p>Iterate from this node up to root.</p>"},{"location":"api/node/#AlgoTree.node.Node.siblings","title":"<code>siblings()</code>","text":"<p>Iterate over sibling nodes.</p>"},{"location":"api/node/#AlgoTree.node.Node.find","title":"<code>find(selector)</code>","text":"<p>Find first node matching selector.</p>"},{"location":"api/node/#AlgoTree.node.Node.find_all","title":"<code>find_all(selector)</code>","text":"<p>Find all nodes matching selector.</p>"},{"location":"api/node/#AlgoTree.node.Node.map","title":"<code>map(fn)</code>","text":"<p>Apply function to all nodes in tree (bottom-up).</p>"},{"location":"api/node/#AlgoTree.node.Node.filter","title":"<code>filter(predicate)</code>","text":"<p>Filter tree to nodes matching predicate.</p> <p>Returns None if this node doesn't match and has no matching descendants. Preserves structure for matching nodes and their ancestors.</p>"},{"location":"api/node/#AlgoTree.node.Node.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert tree to nested dictionary.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary with 'name', attributes, and 'children' list</p>"},{"location":"api/node/#convenience-function","title":"Convenience Function","text":""},{"location":"api/node/#AlgoTree.node.node","title":"<code>AlgoTree.node.node(name, *children, **attrs)</code>","text":"<p>Convenience function to create a node.</p> <p>Allows mixing Node objects and strings as children. Strings are converted to nodes automatically.</p> Example <p>tree = node('root',     node('child1', value=1),     'child2',     node('child3',         'grandchild1',         'grandchild2'     ) )</p>"},{"location":"api/selectors/","title":"Selectors API","text":""},{"location":"api/selectors/#base-class","title":"Base Class","text":""},{"location":"api/selectors/#AlgoTree.selectors.Selector","title":"<code>AlgoTree.selectors.Selector</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for tree node selectors.</p> <p>Selectors can be composed using operators: - &amp; for AND - | for OR - ~ for NOT - ^ for XOR</p>"},{"location":"api/selectors/#AlgoTree.selectors.Selector.__and__","title":"<code>__and__(other)</code>","text":"<p>Combine selectors with AND.</p>"},{"location":"api/selectors/#AlgoTree.selectors.Selector.__invert__","title":"<code>__invert__()</code>","text":"<p>Negate selector.</p>"},{"location":"api/selectors/#AlgoTree.selectors.Selector.__or__","title":"<code>__or__(other)</code>","text":"<p>Combine selectors with OR.</p>"},{"location":"api/selectors/#AlgoTree.selectors.Selector.__xor__","title":"<code>__xor__(other)</code>","text":"<p>Combine selectors with XOR (exclusive or).</p>"},{"location":"api/selectors/#AlgoTree.selectors.Selector.ancestor_of","title":"<code>ancestor_of(descendant_selector)</code>","text":"<p>Match nodes that are ancestors of nodes matching selector.</p>"},{"location":"api/selectors/#AlgoTree.selectors.Selector.at_depth","title":"<code>at_depth(depth)</code>","text":"<p>Match nodes at specific depth.</p>"},{"location":"api/selectors/#AlgoTree.selectors.Selector.at_level","title":"<code>at_level(level)</code>","text":"<p>Alias for at_depth.</p>"},{"location":"api/selectors/#AlgoTree.selectors.Selector.child_of","title":"<code>child_of(parent_selector)</code>","text":"<p>Match nodes that are direct children of parent matching selector.</p>"},{"location":"api/selectors/#AlgoTree.selectors.Selector.count","title":"<code>count(tree)</code>","text":"<p>Count matching nodes.</p>"},{"location":"api/selectors/#AlgoTree.selectors.Selector.descendant_of","title":"<code>descendant_of(ancestor_selector)</code>","text":"<p>Match nodes that are descendants of nodes matching selector.</p>"},{"location":"api/selectors/#AlgoTree.selectors.Selector.exists","title":"<code>exists(tree)</code>","text":"<p>Check if any node matches.</p>"},{"location":"api/selectors/#AlgoTree.selectors.Selector.first","title":"<code>first(tree)</code>","text":"<p>Get first matching node or None.</p>"},{"location":"api/selectors/#AlgoTree.selectors.Selector.matches","title":"<code>matches(node)</code>  <code>abstractmethod</code>","text":"<p>Check if node matches this selector.</p>"},{"location":"api/selectors/#AlgoTree.selectors.Selector.parent_of","title":"<code>parent_of(child_selector)</code>","text":"<p>Match nodes that are direct parents of children matching selector.</p>"},{"location":"api/selectors/#AlgoTree.selectors.Selector.select","title":"<code>select(tree)</code>","text":"<p>Select all matching nodes from tree.</p>"},{"location":"api/selectors/#AlgoTree.selectors.Selector.sibling_of","title":"<code>sibling_of(sibling_selector)</code>","text":"<p>Match nodes that are siblings of nodes matching selector.</p>"},{"location":"api/selectors/#AlgoTree.selectors.Selector.where","title":"<code>where(**attrs)</code>","text":"<p>Add attribute constraints.</p>"},{"location":"api/selectors/#factory-functions","title":"Factory Functions","text":""},{"location":"api/selectors/#AlgoTree.selectors.name","title":"<code>AlgoTree.selectors.name(pattern)</code>","text":"<p>Create name selector.</p>"},{"location":"api/selectors/#AlgoTree.selectors.attrs","title":"<code>AlgoTree.selectors.attrs(**kwargs)</code>","text":"<p>Create attributes selector.</p>"},{"location":"api/selectors/#AlgoTree.selectors.type_","title":"<code>AlgoTree.selectors.type_(node_type)</code>","text":"<p>Create type selector.</p>"},{"location":"api/selectors/#AlgoTree.selectors.predicate","title":"<code>AlgoTree.selectors.predicate(fn, name='custom')</code>","text":"<p>Create predicate selector.</p>"},{"location":"api/selectors/#AlgoTree.selectors.depth","title":"<code>AlgoTree.selectors.depth(d)</code>","text":"<p>Create depth selector.</p>"},{"location":"api/selectors/#AlgoTree.selectors.leaf","title":"<code>AlgoTree.selectors.leaf()</code>","text":"<p>Create leaf selector.</p>"},{"location":"api/selectors/#AlgoTree.selectors.root","title":"<code>AlgoTree.selectors.root()</code>","text":"<p>Create root selector.</p>"},{"location":"api/selectors/#AlgoTree.selectors.any_","title":"<code>AlgoTree.selectors.any_()</code>","text":"<p>Select any node.</p>"},{"location":"api/selectors/#AlgoTree.selectors.none","title":"<code>AlgoTree.selectors.none()</code>","text":"<p>Select no nodes.</p>"},{"location":"api/selectors/#css-like-parser","title":"CSS-like Parser","text":""},{"location":"api/selectors/#AlgoTree.selectors.parse","title":"<code>AlgoTree.selectors.parse(selector_str)</code>","text":"<p>Parse CSS-like selector string.</p> <p>Examples:</p> <p>'node'           - Select by name '*.txt'          - Wildcard pattern '[type=file]'    - Attribute selector 'parent &gt; child' - Direct child 'ancestor child' - Descendant ':leaf'          - Pseudo-selectors ':root'</p>"},{"location":"api/transformers/","title":"Transformers API","text":""},{"location":"api/transformers/#tree-transformers","title":"Tree Transformers","text":""},{"location":"api/transformers/#AlgoTree.transformers.map_","title":"<code>AlgoTree.transformers.map_(fn)</code>","text":"<p>Create map transformer.</p>"},{"location":"api/transformers/#AlgoTree.transformers.filter_","title":"<code>AlgoTree.transformers.filter_(predicate)</code>","text":"<p>Create filter transformer.</p>"},{"location":"api/transformers/#AlgoTree.transformers.prune","title":"<code>AlgoTree.transformers.prune(selector)</code>","text":"<p>Create prune transformer.</p>"},{"location":"api/transformers/#AlgoTree.transformers.graft","title":"<code>AlgoTree.transformers.graft(selector, subtree)</code>","text":"<p>Create graft transformer.</p>"},{"location":"api/transformers/#AlgoTree.transformers.flatten","title":"<code>AlgoTree.transformers.flatten(max_depth=None)</code>","text":"<p>Create flatten transformer.</p>"},{"location":"api/transformers/#AlgoTree.transformers.normalize","title":"<code>AlgoTree.transformers.normalize(**kwargs)</code>","text":"<p>Create normalize transformer.</p>"},{"location":"api/transformers/#AlgoTree.transformers.annotate","title":"<code>AlgoTree.transformers.annotate(selector=None, **annotations)</code>","text":"<p>Create annotate transformer.</p>"},{"location":"api/transformers/#shapers","title":"Shapers","text":""},{"location":"api/transformers/#AlgoTree.transformers.reduce_","title":"<code>AlgoTree.transformers.reduce_(fn, initial, order='preorder')</code>","text":"<p>Create reduce shaper.</p>"},{"location":"api/transformers/#AlgoTree.transformers.fold","title":"<code>AlgoTree.transformers.fold(fn)</code>","text":"<p>Create fold shaper.</p>"},{"location":"api/transformers/#AlgoTree.transformers.extract","title":"<code>AlgoTree.transformers.extract(extractor, selector=None)</code>","text":"<p>Create extract shaper.</p>"},{"location":"api/transformers/#AlgoTree.transformers.to_dict","title":"<code>AlgoTree.transformers.to_dict(children_key='children')</code>","text":"<p>Create to-dict shaper.</p>"},{"location":"api/transformers/#AlgoTree.transformers.to_paths","title":"<code>AlgoTree.transformers.to_paths(delimiter='/', to_leaves_only=True)</code>","text":"<p>Create to-paths shaper.</p>"},{"location":"api/transformers/#composition","title":"Composition","text":""},{"location":"api/transformers/#AlgoTree.transformers.Pipeline","title":"<code>AlgoTree.transformers.Pipeline</code>","text":"<p>               Bases: <code>Transformer[Any, Any]</code></p> <p>Sequential composition of transformers.</p>"},{"location":"api/transformers/#AlgoTree.transformers.Pipeline.__call__","title":"<code>__call__(tree)</code>","text":"<p>Apply all transformations in sequence.</p>"},{"location":"api/transformers/#AlgoTree.transformers.Pipeline.__or__","title":"<code>__or__(other)</code>","text":"<p>Add transformer to pipeline (alternative syntax).</p>"},{"location":"api/transformers/#AlgoTree.transformers.Pipeline.__rshift__","title":"<code>__rshift__(other)</code>","text":"<p>Add transformer to pipeline.</p>"},{"location":"api/transformers/#AlgoTree.transformers.Pipeline.partial","title":"<code>partial(tree, steps)</code>","text":"<p>Apply only first N steps of pipeline.</p>"},{"location":"api/transformers/#AlgoTree.transformers.ParallelTransformer","title":"<code>AlgoTree.transformers.ParallelTransformer</code>","text":"<p>               Bases: <code>Transformer[T, S]</code>, <code>Generic[T, S]</code></p> <p>Apply transformers in parallel and merge results.</p>"},{"location":"api/transformers/#AlgoTree.transformers.ParallelTransformer.__call__","title":"<code>__call__(tree)</code>","text":"<p>Apply all transformers and merge results.</p>"},{"location":"api/transformers/#AlgoTree.transformers.RepeatTransformer","title":"<code>AlgoTree.transformers.RepeatTransformer</code>","text":"<p>               Bases: <code>Transformer[T, T]</code>, <code>Generic[T]</code></p> <p>Apply transformer multiple times.</p>"},{"location":"api/transformers/#AlgoTree.transformers.ConditionalTransformer","title":"<code>AlgoTree.transformers.ConditionalTransformer</code>","text":"<p>               Bases: <code>Transformer[T, Union[T, S]]</code>, <code>Generic[T, S]</code></p> <p>Apply transformer conditionally.</p>"},{"location":"api/tree/","title":"Tree API","text":""},{"location":"api/tree/#AlgoTree.tree.Tree","title":"<code>AlgoTree.tree.Tree</code>","text":"<p>Immutable tree wrapper with fluent, composable API.</p> <p>All operations return new Tree instances, enabling chaining. The tree itself is never mutated.</p>"},{"location":"api/tree/#AlgoTree.tree.Tree.root","title":"<code>root</code>  <code>property</code>","text":"<p>Get root node (immutable).</p>"},{"location":"api/tree/#AlgoTree.tree.Tree.size","title":"<code>size</code>  <code>property</code>","text":"<p>Total number of nodes.</p>"},{"location":"api/tree/#AlgoTree.tree.Tree.height","title":"<code>height</code>  <code>property</code>","text":"<p>Height of tree.</p>"},{"location":"api/tree/#AlgoTree.tree.Tree.leaves","title":"<code>leaves</code>  <code>property</code>","text":"<p>Get all leaf nodes.</p>"},{"location":"api/tree/#AlgoTree.tree.Tree.is_empty","title":"<code>is_empty</code>  <code>property</code>","text":"<p>Check if tree is empty.</p>"},{"location":"api/tree/#AlgoTree.tree.Tree.__init__","title":"<code>__init__(root)</code>","text":"<p>Initialize tree with root node.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>Union[Node, str]</code> <p>Root node or name for new root</p> required"},{"location":"api/tree/#AlgoTree.tree.Tree.from_dict","title":"<code>from_dict(data, children_key='children')</code>  <code>classmethod</code>","text":"<p>Create tree from nested dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[str, Any]</code> <p>Dictionary with 'name' and optional children</p> required <code>children_key</code> <code>str</code> <p>Key name for children list</p> <code>'children'</code> Example <p>tree = Tree.from_dict({     'name': 'root',     'value': 1,     'children': [         {'name': 'child1', 'value': 2},         {'name': 'child2', 'value': 3}     ] })</p>"},{"location":"api/tree/#AlgoTree.tree.Tree.from_paths","title":"<code>from_paths(paths, delimiter='/')</code>  <code>classmethod</code>","text":"<p>Create tree from list of paths.</p> <p>Parameters:</p> Name Type Description Default <code>paths</code> <code>List[str]</code> <p>List of path strings</p> required <code>delimiter</code> <code>str</code> <p>Path delimiter</p> <code>'/'</code> Example <p>tree = Tree.from_paths([     'root/a/b',     'root/a/c',     'root/d' ])</p>"},{"location":"api/tree/#AlgoTree.tree.Tree.map","title":"<code>map(fn)</code>","text":"<p>Map function over all nodes.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[[Node], Union[Node, Dict[str, Any]]]</code> <p>Function that takes a node and returns either: - A new node to replace it - A dict of attributes to update - None to keep node unchanged</p> required <p>Returns:</p> Type Description <code>Tree</code> <p>New tree with mapped values</p>"},{"location":"api/tree/#AlgoTree.tree.Tree.filter","title":"<code>filter(predicate)</code>","text":"<p>Filter tree to nodes matching predicate.</p> <p>Preserves tree structure - keeps ancestors of matching nodes.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[[Node], bool]</code> <p>Function that returns True for nodes to keep</p> required <p>Returns:</p> Type Description <code>Tree</code> <p>New filtered tree</p>"},{"location":"api/tree/#AlgoTree.tree.Tree.reduce","title":"<code>reduce(fn, initial, order='preorder')</code>","text":"<p>Reduce tree to single value.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[[T, Node], T]</code> <p>Reduction function (accumulator, node) -&gt; new_accumulator</p> required <code>initial</code> <code>T</code> <p>Initial accumulator value</p> required <code>order</code> <code>str</code> <p>Traversal order ('preorder', 'postorder', 'levelorder')</p> <code>'preorder'</code> <p>Returns:</p> Type Description <code>T</code> <p>Final reduced value</p>"},{"location":"api/tree/#AlgoTree.tree.Tree.fold","title":"<code>fold(fn)</code>","text":"<p>Fold tree bottom-up, combining child results.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[[Node, List[T]], T]</code> <p>Function (node, child_results) -&gt; result</p> required <p>Returns:</p> Type Description <code>T</code> <p>Final folded value</p>"},{"location":"api/tree/#AlgoTree.tree.Tree.find","title":"<code>find(selector)</code>","text":"<p>Find first node matching selector.</p>"},{"location":"api/tree/#AlgoTree.tree.Tree.find_all","title":"<code>find_all(selector)</code>","text":"<p>Find all nodes matching selector.</p>"},{"location":"api/tree/#AlgoTree.tree.Tree.exists","title":"<code>exists(selector)</code>","text":"<p>Check if any node matches selector.</p>"},{"location":"api/tree/#AlgoTree.tree.Tree.count","title":"<code>count(selector=None)</code>","text":"<p>Count nodes matching selector (or all nodes if None).</p>"},{"location":"api/tree/#AlgoTree.tree.Tree.select","title":"<code>select(selector)</code>","text":"<p>Select nodes matching selector (returns iterator).</p>"},{"location":"api/tree/#AlgoTree.tree.Tree.prune","title":"<code>prune(selector)</code>","text":"<p>Remove nodes matching selector.</p> <p>Parameters:</p> Name Type Description Default <code>selector</code> <code>Union[str, Callable[[Node], bool]]</code> <p>Node selector (string pattern or predicate)</p> required <p>Returns:</p> Type Description <code>Tree</code> <p>New tree with nodes pruned</p>"},{"location":"api/tree/#AlgoTree.tree.Tree.graft","title":"<code>graft(selector, subtree)</code>","text":"<p>Add subtree to nodes matching selector.</p> <p>Parameters:</p> Name Type Description Default <code>selector</code> <code>Union[str, Callable[[Node], bool]]</code> <p>Where to graft</p> required <code>subtree</code> <code>Union[Node, Tree]</code> <p>Tree or node to graft</p> required <p>Returns:</p> Type Description <code>Tree</code> <p>New tree with subtrees grafted</p>"},{"location":"api/tree/#AlgoTree.tree.Tree.flatten","title":"<code>flatten(max_depth=None)</code>","text":"<p>Flatten tree to specified depth.</p> <p>Nodes beyond max_depth have their descendants moved up to become direct children of the node at max_depth.</p> <p>Parameters:</p> Name Type Description Default <code>max_depth</code> <code>Optional[int]</code> <p>Maximum depth (None for complete flattening to root's children)</p> <code>None</code> <p>Returns:</p> Type Description <code>Tree</code> <p>New flattened tree</p>"},{"location":"api/tree/#AlgoTree.tree.Tree.get_path","title":"<code>get_path(path, delimiter='/')</code>","text":"<p>Get node at path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path string (e.g., 'root/child/grandchild')</p> required <code>delimiter</code> <code>str</code> <p>Path delimiter</p> <code>'/'</code> <p>Returns:</p> Type Description <code>Optional[Node]</code> <p>Node at path or None</p>"},{"location":"api/tree/#AlgoTree.tree.Tree.paths","title":"<code>paths(to_leaves_only=True)</code>","text":"<p>Get all paths in tree.</p> <p>Parameters:</p> Name Type Description Default <code>to_leaves_only</code> <code>bool</code> <p>If True, only return paths to leaves</p> <code>True</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of path strings</p>"},{"location":"api/tree/#AlgoTree.tree.Tree.nodes","title":"<code>nodes()</code>","text":"<p>Get all nodes as list.</p>"},{"location":"api/tree/#AlgoTree.tree.Tree.to_dict","title":"<code>to_dict(children_key='children')</code>","text":"<p>Export tree to nested dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>children_key</code> <code>str</code> <p>Key name for children list</p> <code>'children'</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Nested dictionary representation</p>"},{"location":"api/tree/#AlgoTree.tree.Tree.to_paths","title":"<code>to_paths(delimiter='/')</code>","text":"<p>Export tree as list of paths.</p>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#from-pypi","title":"From PyPI","text":"<pre><code>pip install AlgoTree\n</code></pre>"},{"location":"getting-started/installation/#from-source","title":"From Source","text":"<pre><code>git clone https://github.com/queelius/AlgoTree.git\ncd AlgoTree\npip install -e .\n</code></pre>"},{"location":"getting-started/installation/#optional-dependencies","title":"Optional Dependencies","text":""},{"location":"getting-started/installation/#algograph-interoperability","title":"AlgoGraph Interoperability","text":"<p>For converting trees to/from graph representations:</p> <pre><code>pip install AlgoGraph\n</code></pre>"},{"location":"getting-started/installation/#development","title":"Development","text":"<p>For development and testing:</p> <pre><code>pip install AlgoTree[dev]\n</code></pre>"},{"location":"getting-started/installation/#verifying-installation","title":"Verifying Installation","text":"<pre><code>from AlgoTree import Node, pretty_tree\n\ntree = Node(\"hello\", Node(\"world\"))\nprint(pretty_tree(tree))\n</code></pre> <p>Output: <pre><code>hello\n\u2514\u2500\u2500 world\n</code></pre></p>"},{"location":"getting-started/introduction/","title":"Introduction","text":"<p>AlgoTree is a Python library for working with tree data structures. Version 2.0 introduces a modern, immutable-by-default API following functional programming principles.</p>"},{"location":"getting-started/introduction/#core-principles","title":"Core Principles","text":"<ol> <li>Immutability: All operations return new objects; nothing is mutated</li> <li>Composability: Small functions that combine well using operators</li> <li>Functional Style: Method chaining and pure functions</li> <li>Type Safety: Full type hints for IDE support</li> </ol>"},{"location":"getting-started/introduction/#core-components","title":"Core Components","text":""},{"location":"getting-started/introduction/#node","title":"Node","text":"<p>The fundamental building block. Nodes are immutable - all operations return new nodes.</p> <pre><code>from AlgoTree import Node\n\nroot = Node(\"root\",\n    Node(\"child1\", attrs={\"value\": 1}),\n    Node(\"child2\", attrs={\"value\": 2})\n)\n\n# Immutable - returns new node\nrenamed = root.with_name(\"new_root\")\n</code></pre>"},{"location":"getting-started/introduction/#tree","title":"Tree","text":"<p>A wrapper that provides functional operations on nodes.</p> <pre><code>from AlgoTree import Tree, Node\n\ntree = Tree(Node(\"root\", Node(\"a\"), Node(\"b\")))\nfiltered = tree.filter(lambda n: n.name != \"b\")\n</code></pre>"},{"location":"getting-started/introduction/#selectors","title":"Selectors","text":"<p>Composable pattern matching for finding nodes.</p> <pre><code>from AlgoTree import name, attrs, leaf\n\n# Combine selectors with operators\nselector = name(\"config\") &amp; attrs(type=\"file\")\nmatches = tree.find_all(selector)\n</code></pre>"},{"location":"getting-started/introduction/#transformers","title":"Transformers","text":"<p>Reusable, composable tree operations.</p> <pre><code>from AlgoTree import map_, filter_, prune\n\npipeline = map_(lambda n: {\"tagged\": True}) &gt;&gt; filter_(lambda n: n.depth &gt; 0)\nresult = pipeline(tree)\n</code></pre>"},{"location":"getting-started/introduction/#primary-vs-secondary-interface","title":"Primary vs Secondary Interface","text":"<p>Primary Interface (Recommended): The fluent Python API (<code>Node</code>, <code>Tree</code>, transformers, selectors) for all scripting, automation, and programmatic use.</p> <p>Secondary Interface: The interactive shell (<code>AlgoTree.shell</code>) for exploration, quick queries, and terminal workflows - not for scripting or automation.</p>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>This guide will get you up and running with AlgoTree in minutes.</p>"},{"location":"getting-started/quickstart/#creating-trees","title":"Creating Trees","text":""},{"location":"getting-started/quickstart/#using-the-node-constructor","title":"Using the Node Constructor","text":"<pre><code>from AlgoTree import Node\n\ntree = Node(\"root\",\n    Node(\"src\",\n        Node(\"main.py\", attrs={\"size\": 1024}),\n        Node(\"utils.py\", attrs={\"size\": 512})\n    ),\n    Node(\"docs\",\n        Node(\"README.md\")\n    )\n)\n</code></pre>"},{"location":"getting-started/quickstart/#using-the-convenience-function","title":"Using the Convenience Function","text":"<pre><code>from AlgoTree import node\n\n# Strings auto-convert to nodes, kwargs become attrs\ntree = node(\"root\",\n    node(\"src\",\n        node(\"main.py\", size=1024),\n        node(\"utils.py\", size=512)\n    ),\n    \"docs\"  # Auto-converted to Node(\"docs\")\n)\n</code></pre>"},{"location":"getting-started/quickstart/#parsing-from-text","title":"Parsing from Text","text":"<pre><code>from AlgoTree import parse_tree\n\n# Visual format\ntree = parse_tree(\"\"\"\nroot\n\u251c\u2500\u2500 src\n\u2502   \u251c\u2500\u2500 main.py\n\u2502   \u2514\u2500\u2500 utils.py\n\u2514\u2500\u2500 docs\n    \u2514\u2500\u2500 README.md\n\"\"\")\n\n# Indent format\ntree = parse_tree(\"\"\"\nroot\n  src\n    main.py\n    utils.py\n  docs\n    README.md\n\"\"\")\n\n# S-expression format\ntree = parse_tree(\"(root (src (main.py) (utils.py)) (docs (README.md)))\")\n</code></pre>"},{"location":"getting-started/quickstart/#traversing-trees","title":"Traversing Trees","text":"<pre><code># Walk all nodes\nfor node in tree.walk(\"preorder\"):\n    print(node.name)\n\n# Just leaves\nfor leaf in tree.leaves():\n    print(leaf.name)\n\n# Just descendants\nfor desc in tree.descendants():\n    print(desc.name)\n</code></pre>"},{"location":"getting-started/quickstart/#finding-nodes","title":"Finding Nodes","text":"<pre><code># By name\nnode = tree.find(\"main.py\")\n\n# By predicate\nlarge_files = tree.find_all(lambda n: n.get(\"size\", 0) &gt; 500)\n\n# By pattern\npy_files = tree.find_all(\"*.py\")\n</code></pre>"},{"location":"getting-started/quickstart/#transforming-trees","title":"Transforming Trees","text":"<p>All transformations are immutable - they return new trees:</p> <pre><code># Add attributes\ntagged = tree.map(lambda n: n.with_attrs(processed=True))\n\n# Filter nodes\nfiltered = tree.filter(lambda n: n.get(\"size\", 0) &gt; 100)\n\n# Remove nodes\npruned = tree.filter(lambda n: n.name != \"utils.py\")\n</code></pre>"},{"location":"getting-started/quickstart/#visualizing-trees","title":"Visualizing Trees","text":"<pre><code>from AlgoTree import pretty_tree\n\nprint(pretty_tree(tree))\n</code></pre> <p>Output: <pre><code>root\n\u251c\u2500\u2500 src\n\u2502   \u251c\u2500\u2500 main.py\n\u2502   \u2514\u2500\u2500 utils.py\n\u2514\u2500\u2500 docs\n    \u2514\u2500\u2500 README.md\n</code></pre></p>"},{"location":"getting-started/quickstart/#exporting-trees","title":"Exporting Trees","text":"<pre><code>from AlgoTree import export_tree, save_tree\n\n# To JSON string\njson_str = export_tree(tree, \"json\")\n\n# To GraphViz DOT\ndot_str = export_tree(tree, \"graphviz\")\n\n# Save to file\nsave_tree(tree, \"tree.json\")\nsave_tree(tree, \"tree.dot\")\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Node API - Deep dive into Node operations</li> <li>Selectors - Pattern matching for nodes</li> <li>Transformers - Composable tree operations</li> </ul>"},{"location":"guide/builders/","title":"Builders","text":"<p>AlgoTree provides multiple builder patterns for constructing trees fluently.</p>"},{"location":"guide/builders/#treebuilder","title":"TreeBuilder","text":"<p>The primary fluent builder for constructing trees:</p> <pre><code>from AlgoTree import TreeBuilder\n\ntree = (\n    TreeBuilder('root')\n    .attr(type='directory')\n    .child('src',\n        TreeBuilder('main.py', type='file', size=1024),\n        TreeBuilder('utils.py', type='file', size=512)\n    )\n    .child('docs',\n        TreeBuilder('README.md', type='file')\n    )\n    .build()\n)\n</code></pre>"},{"location":"guide/builders/#methods","title":"Methods","text":"<pre><code>builder = TreeBuilder('name')\n\n# Add attributes\nbuilder.attr(key=value)\nbuilder.attrs({'key': 'value'})\n\n# Add children\nbuilder.child('name')\nbuilder.child('name', TreeBuilder(...), TreeBuilder(...))\nbuilder.children('a', 'b', TreeBuilder('c'))\n\n# Navigation\nbuilder.up()    # Move to parent\nbuilder.root()  # Move to root\n\n# Build\ntree = builder.build()       # Returns Tree\nnode = builder.build_node()  # Returns Node\n</code></pre>"},{"location":"guide/builders/#operator-syntax","title":"Operator Syntax","text":"<pre><code># Add child with &lt;&lt;\nbuilder = TreeBuilder('root') &lt;&lt; 'child1' &lt;&lt; 'child2'\n\n# Add attributes with ()\nbuilder = TreeBuilder('root')(type='file', size=1024)\n</code></pre>"},{"location":"guide/builders/#dsl-functions","title":"DSL Functions","text":"<p>Quick tree construction with <code>tree()</code>, <code>branch()</code>, and <code>leaf()</code>:</p> <pre><code>from AlgoTree import tree, branch, leaf\n\nmy_tree = tree('root',\n    branch('src',\n        leaf('main.py', type='file'),\n        leaf('utils.py', type='file')\n    ),\n    branch('docs',\n        leaf('README.md', type='file')\n    ),\n    type='directory'\n).build()\n</code></pre>"},{"location":"guide/builders/#fluenttree","title":"FluentTree","text":"<p>Chainable wrapper for Tree operations:</p> <pre><code>from AlgoTree import FluentTree, Node\n\nfluent = FluentTree(Node('root', Node('a'), Node('b')))\n\n# Chain operations\nresult = (\n    fluent\n    .map(lambda n: n.with_attrs(visited=True))\n    .filter(lambda n: n.depth &gt; 0)\n    .prune('temp*')\n    .tree  # Get underlying Tree\n)\n\n# Pipe operators\nfrom AlgoTree import map_, filter_\n\nresult = fluent | map_(lambda n: {...})\nresult = fluent &gt;&gt; filter_(...) &gt;&gt; to_dict()\n</code></pre>"},{"location":"guide/builders/#methods_1","title":"Methods","text":"<pre><code># Chainable (return FluentTree)\nfluent.map(fn)\nfluent.filter(pred)\nfluent.prune(selector)\nfluent.graft(selector, subtree)\nfluent.flatten(max_depth)\nfluent.transform(fn)\n\n# Terminal (return values)\nfluent.find(selector)\nfluent.find_all(selector)\nfluent.reduce(fn, initial)\nfluent.fold(fn)\nfluent.to_dict()\nfluent.to_paths()\n</code></pre>"},{"location":"guide/builders/#treecontext","title":"TreeContext","text":"<p>Context manager for building trees with Python's <code>with</code> statement:</p> <pre><code>from AlgoTree import TreeContext\n\nwith TreeContext('root') as ctx:\n    with ctx.child('src') as src:\n        with src.child('main.py', type='file'):\n            pass\n        with src.child('utils.py', type='file'):\n            pass\n    with ctx.child('docs') as docs:\n        with docs.child('README.md', type='file'):\n            pass\n\ntree = ctx.build()\n</code></pre>"},{"location":"guide/builders/#adding-children-without-context","title":"Adding Children Without Context","text":"<pre><code>with TreeContext('root') as ctx:\n    with ctx.child('src') as src:\n        # Quick add without nesting\n        src.add_child('file1.py', type='file')\n        src.add_child('file2.py', type='file')\n</code></pre>"},{"location":"guide/builders/#quickbuilder","title":"QuickBuilder","text":"<p>Path-based builder for simple tree structures:</p> <pre><code>from AlgoTree import QuickBuilder\n\ntree = (\n    QuickBuilder()\n    .root('app')\n    .add('src/main.py', type='file')\n    .add('src/utils.py', type='file')\n    .add('docs/README.md', type='file')\n    .add('tests/test_main.py', type='file')\n    .build()\n)\n</code></pre>"},{"location":"guide/builders/#with-custom-delimiter","title":"With Custom Delimiter","text":"<pre><code>tree = (\n    QuickBuilder()\n    .root('app')\n    .add('src.main', type='module')\n    .add('src.utils', type='module')\n    .build(delimiter='.')\n)\n</code></pre>"},{"location":"guide/builders/#choosing-a-builder","title":"Choosing a Builder","text":"Builder Best For <code>TreeBuilder</code> Full control, complex trees <code>tree()/branch()/leaf()</code> Quick DSL-style construction <code>FluentTree</code> Chaining transformations <code>TreeContext</code> Visually nested structure <code>QuickBuilder</code> Path-based construction"},{"location":"guide/builders/#examples","title":"Examples","text":""},{"location":"guide/builders/#complex-tree-with-treebuilder","title":"Complex Tree with TreeBuilder","text":"<pre><code>from AlgoTree import TreeBuilder\n\nproject = (\n    TreeBuilder('project', type='directory')\n    .child('src',\n        TreeBuilder('core',\n            TreeBuilder('engine.py', type='file', lines=500),\n            TreeBuilder('utils.py', type='file', lines=200)\n        ),\n        TreeBuilder('api',\n            TreeBuilder('handlers.py', type='file', lines=300),\n            TreeBuilder('routes.py', type='file', lines=150)\n        )\n    )\n    .child('tests',\n        TreeBuilder('test_core.py', type='file', lines=400),\n        TreeBuilder('test_api.py', type='file', lines=250)\n    )\n    .child('docs',\n        TreeBuilder('README.md', type='file'),\n        TreeBuilder('API.md', type='file')\n    )\n    .build()\n)\n</code></pre>"},{"location":"guide/builders/#from-paths-with-quickbuilder","title":"From Paths with QuickBuilder","text":"<pre><code>from AlgoTree import QuickBuilder\n\n# Build tree from file listing\nfiles = [\n    'src/main.py',\n    'src/utils/helpers.py',\n    'src/utils/validators.py',\n    'tests/test_main.py',\n    'README.md'\n]\n\nbuilder = QuickBuilder().root('project')\nfor path in files:\n    builder.add(path, type='file')\ntree = builder.build()\n</code></pre>"},{"location":"guide/builders/#fluenttree-pipeline","title":"FluentTree Pipeline","text":"<pre><code>from AlgoTree import FluentTree, Node, map_, filter_\n\ntree = Node('root',\n    Node('a', attrs={'value': 10}),\n    Node('b', attrs={'value': 5}),\n    Node('c', attrs={'value': 15})\n)\n\n# Chain operations\nresult = (\n    FluentTree(tree)\n    .filter(lambda n: n.get('value', 0) &gt; 7)\n    .map(lambda n: n.with_attrs(\n        value=n.get('value', 0) * 2\n    ))\n    .to_dict()\n)\n</code></pre>"},{"location":"guide/dsl/","title":"DSL Parsing","text":"<p>AlgoTree supports parsing trees from multiple text formats through its Domain Specific Language (DSL) parser.</p>"},{"location":"guide/dsl/#supported-formats","title":"Supported Formats","text":""},{"location":"guide/dsl/#visual-format-unicode-tree","title":"Visual Format (Unicode Tree)","text":"<p>The visual format uses Unicode box-drawing characters:</p> <pre><code>from AlgoTree import parse_tree\n\ntree = parse_tree(\"\"\"\ncompany\n\u251c\u2500\u2500 engineering\n\u2502   \u251c\u2500\u2500 frontend\n\u2502   \u2514\u2500\u2500 backend\n\u2514\u2500\u2500 sales\n\"\"\")\n</code></pre> <p>With attributes in brackets:</p> <pre><code>tree = parse_tree(\"\"\"\ncompany[type:tech]\n\u251c\u2500\u2500 engineering[head:Alice]\n\u2502   \u251c\u2500\u2500 frontend[size:5]\n\u2502   \u2514\u2500\u2500 backend[size:8]\n\u2514\u2500\u2500 sales[head:Bob]\n\"\"\")\n</code></pre>"},{"location":"guide/dsl/#indent-format","title":"Indent Format","text":"<p>The indent format uses whitespace for structure:</p> <pre><code>tree = parse_tree(\"\"\"\ncompany\n  engineering\n    frontend\n    backend\n  sales\n\"\"\")\n</code></pre> <p>With attributes (YAML-like):</p> <pre><code>tree = parse_tree(\"\"\"\ncompany: {type: tech, revenue: 1M}\n  engineering: {head: Alice}\n    frontend: {size: 5}\n    backend: {size: 8}\n  sales: {head: Bob}\n\"\"\")\n</code></pre> <p>Or with bracket notation:</p> <pre><code>tree = parse_tree(\"\"\"\ncompany[type:tech]\n  engineering[head:Alice]\n    frontend[size:5]\n    backend[size:8]\n  sales[head:Bob]\n\"\"\")\n</code></pre>"},{"location":"guide/dsl/#s-expression-format","title":"S-Expression Format","text":"<p>The S-expression format uses parentheses:</p> <pre><code>tree = parse_tree(\"\"\"\n(company\n  (engineering\n    (frontend)\n    (backend))\n  (sales))\n\"\"\")\n</code></pre> <p>With attributes (Lisp-style keywords):</p> <pre><code>tree = parse_tree(\"\"\"\n(company :type tech :revenue 1M\n  (engineering :head Alice\n    (frontend :size 5)\n    (backend :size 8))\n  (sales :head Bob))\n\"\"\")\n</code></pre>"},{"location":"guide/dsl/#auto-detection","title":"Auto-Detection","text":"<p>The parser auto-detects the format:</p> <pre><code>from AlgoTree import parse_tree\n\n# Detects visual format (has box characters)\ntree = parse_tree(\"\"\"\nroot\n\u251c\u2500\u2500 child1\n\u2514\u2500\u2500 child2\n\"\"\")\n\n# Detects S-expression (starts with parenthesis)\ntree = parse_tree(\"(root (child1) (child2))\")\n\n# Detects indent format (default)\ntree = parse_tree(\"\"\"\nroot\n  child1\n  child2\n\"\"\")\n</code></pre>"},{"location":"guide/dsl/#explicit-format","title":"Explicit Format","text":"<p>Force a specific format:</p> <pre><code>tree = parse_tree(text, format='visual')\ntree = parse_tree(text, format='indent')\ntree = parse_tree(text, format='sexpr')\n</code></pre>"},{"location":"guide/dsl/#using-treedsl-directly","title":"Using TreeDSL Directly","text":"<p>For more control, use the <code>TreeDSL</code> class:</p> <pre><code>from AlgoTree.dsl import TreeDSL\n\n# Parse with auto-detection\nnode = TreeDSL.parse(text)\n\n# Parse with specific format\nnode = TreeDSL.parse(text, format='visual')\n</code></pre>"},{"location":"guide/dsl/#attribute-syntax","title":"Attribute Syntax","text":""},{"location":"guide/dsl/#bracket-notation","title":"Bracket Notation","text":"<pre><code>node[key:value, key2:value2]\n</code></pre> <p>Values are auto-parsed:</p> <ul> <li>Numbers: <code>size:123</code>, <code>ratio:3.14</code></li> <li>Booleans: <code>active:true</code>, <code>hidden:false</code></li> <li>Strings: <code>name:\"John Doe\"</code>, <code>type:file</code></li> </ul>"},{"location":"guide/dsl/#colon-notation-indent-format","title":"Colon Notation (Indent Format)","text":"<pre><code>node: {key: value, key2: value2}\n</code></pre>"},{"location":"guide/dsl/#keyword-notation-s-expression","title":"Keyword Notation (S-Expression)","text":"<pre><code>(node :key value :key2 value2)\n</code></pre>"},{"location":"guide/dsl/#examples","title":"Examples","text":""},{"location":"guide/dsl/#parsing-file-trees","title":"Parsing File Trees","text":"<pre><code>from AlgoTree import parse_tree\n\n# From `tree` command output\ntree = parse_tree(\"\"\"\nproject\n\u251c\u2500\u2500 src\n\u2502   \u251c\u2500\u2500 main.py\n\u2502   \u2514\u2500\u2500 utils.py\n\u251c\u2500\u2500 tests\n\u2502   \u2514\u2500\u2500 test_main.py\n\u2514\u2500\u2500 README.md\n\"\"\")\n</code></pre>"},{"location":"guide/dsl/#parsing-configuration","title":"Parsing Configuration","text":"<pre><code>tree = parse_tree(\"\"\"\nconfig\n  database\n    host: localhost\n    port: 5432\n  cache\n    enabled: true\n    ttl: 3600\n\"\"\")\n</code></pre>"},{"location":"guide/dsl/#parsing-org-charts","title":"Parsing Org Charts","text":"<pre><code>tree = parse_tree(\"\"\"\n(CEO :name \"Jane Smith\"\n  (CTO :name \"Bob Wilson\"\n    (Engineering :size 50)\n    (DevOps :size 10))\n  (CFO :name \"Alice Brown\"\n    (Finance :size 20)\n    (HR :size 15)))\n\"\"\")\n</code></pre>"},{"location":"guide/dsl/#error-handling","title":"Error Handling","text":"<pre><code>from AlgoTree import parse_tree\n\ntry:\n    tree = parse_tree(\"invalid (( tree\")\nexcept ValueError as e:\n    print(f\"Parse error: {e}\")\n</code></pre>"},{"location":"guide/dsl/#format-comparison","title":"Format Comparison","text":"Format Best For Visual Output from <code>tree</code> command, human-readable docs Indent Configuration files, YAML-like data S-Expression Programmatic generation, Lisp users"},{"location":"guide/export/","title":"Exporting Trees","text":"<p>AlgoTree can export trees to various formats for visualization, serialization, and integration.</p>"},{"location":"guide/export/#quick-export","title":"Quick Export","text":"<p>Use <code>export_tree()</code> for simple exports:</p> <pre><code>from AlgoTree import Node, export_tree\n\ntree = Node(\"root\", Node(\"a\"), Node(\"b\"))\n\n# Export to various formats\njson_str = export_tree(tree, \"json\")\ndot_str = export_tree(tree, \"graphviz\")\nmermaid_str = export_tree(tree, \"mermaid\")\nyaml_str = export_tree(tree, \"yaml\")\nxml_str = export_tree(tree, \"xml\")\nhtml_str = export_tree(tree, \"html\")\n</code></pre>"},{"location":"guide/export/#saving-to-files","title":"Saving to Files","text":"<p>Use <code>save_tree()</code> with format auto-detection:</p> <pre><code>from AlgoTree import save_tree\n\n# Format detected from extension\nsave_tree(tree, \"tree.json\")      # JSON\nsave_tree(tree, \"tree.dot\")       # GraphViz\nsave_tree(tree, \"tree.mmd\")       # Mermaid\nsave_tree(tree, \"tree.yaml\")      # YAML\nsave_tree(tree, \"tree.xml\")       # XML\nsave_tree(tree, \"tree.html\")      # HTML\n\n# Explicit format\nsave_tree(tree, \"output.txt\", format=\"ascii\")\n</code></pre>"},{"location":"guide/export/#export-formats","title":"Export Formats","text":""},{"location":"guide/export/#json","title":"JSON","text":"<pre><code>from AlgoTree import export_tree\n\njson_str = export_tree(tree, \"json\", indent=2)\n</code></pre> <p>Output: <pre><code>{\n  \"name\": \"root\",\n  \"children\": [\n    {\"name\": \"a\", \"children\": []},\n    {\"name\": \"b\", \"children\": []}\n  ]\n}\n</code></pre></p>"},{"location":"guide/export/#asciiunicode-tree","title":"ASCII/Unicode Tree","text":"<pre><code># ASCII\nascii_tree = export_tree(tree, \"ascii\")\n\n# Unicode (box drawing characters)\nunicode_tree = export_tree(tree, \"unicode\")\n</code></pre> <p>Output: <pre><code>root\n\u251c\u2500\u2500 a\n\u2514\u2500\u2500 b\n</code></pre></p>"},{"location":"guide/export/#graphviz-dot","title":"GraphViz DOT","text":"<pre><code>dot = export_tree(tree, \"graphviz\", name=\"MyTree\")\n</code></pre> <p>Output: <pre><code>digraph MyTree {\n    node0 [label=\"root\"];\n    node1 [label=\"a\"];\n    node2 [label=\"b\"];\n    node0 -&gt; node1;\n    node0 -&gt; node2;\n}\n</code></pre></p> <p>With custom attributes:</p> <pre><code>from AlgoTree.exporters import TreeExporter\n\ndot = TreeExporter.to_graphviz(\n    tree,\n    name=\"FileTree\",\n    node_attr=lambda n: {\n        \"label\": f\"{n.name}\\\\n{n.get('size', '')}\",\n        \"shape\": \"box\" if n.is_leaf else \"ellipse\"\n    },\n    edge_attr=lambda parent, child: {\n        \"style\": \"dashed\" if child.get(\"optional\") else \"solid\"\n    },\n    graph_attr={\"rankdir\": \"LR\"}\n)\n</code></pre>"},{"location":"guide/export/#mermaid","title":"Mermaid","text":"<pre><code>mermaid = export_tree(tree, \"mermaid\")\n</code></pre> <p>Output: <pre><code>graph TD\n    N0(root)\n    N1(a)\n    N2(b)\n    N0 --&gt; N1\n    N0 --&gt; N2\n</code></pre></p> <p>With options:</p> <pre><code>from AlgoTree.exporters import TreeExporter\n\nmermaid = TreeExporter.to_mermaid(\n    tree,\n    direction=\"LR\",      # LR, RL, TB, TD, BT\n    node_shape=\"round\",  # round, square, circle, rhombus, stadium\n    node_text=lambda n: f\"{n.name}&lt;br/&gt;{n.get('type', '')}\"\n)\n</code></pre>"},{"location":"guide/export/#yaml","title":"YAML","text":"<pre><code>yaml = export_tree(tree, \"yaml\")\n</code></pre> <p>Output: <pre><code>- name: root\n  children:\n    - name: a\n    - name: b\n</code></pre></p>"},{"location":"guide/export/#xml","title":"XML","text":"<pre><code>xml = export_tree(tree, \"xml\")\n</code></pre> <p>Output: <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;tree&gt;\n  &lt;node name=\"root\"&gt;\n    &lt;node name=\"a\" /&gt;\n    &lt;node name=\"b\" /&gt;\n  &lt;/node&gt;\n&lt;/tree&gt;\n</code></pre></p>"},{"location":"guide/export/#html","title":"HTML","text":"<p>Interactive HTML with collapsible nodes:</p> <pre><code>from AlgoTree.exporters import TreeExporter\n\nhtml = TreeExporter.to_html(\n    tree,\n    include_styles=True,\n    collapsible=True\n)\n</code></pre>"},{"location":"guide/export/#flatgraph-format","title":"Flat/Graph Format","text":"<p>Flat dictionary format for graph interoperability:</p> <pre><code>flat = export_tree(tree, \"flat\")\n</code></pre> <p>Output: <pre><code>{\n  \"root\": {\n    \".name\": \"root\",\n    \".children\": [\"a\", \"b\"]\n  },\n  \"root/a\": {\n    \".name\": \"a\",\n    \".children\": []\n  },\n  \"root/b\": {\n    \".name\": \"b\",\n    \".children\": []\n  }\n}\n</code></pre></p>"},{"location":"guide/export/#pretty-printing","title":"Pretty Printing","text":"<p>For console output, use <code>pretty_tree()</code>:</p> <pre><code>from AlgoTree import pretty_tree\n\nprint(pretty_tree(tree))\n</code></pre> <p>Output: <pre><code>root\n\u251c\u2500\u2500 a\n\u2514\u2500\u2500 b\n</code></pre></p>"},{"location":"guide/export/#treeexporter-class","title":"TreeExporter Class","text":"<p>Direct access to exporters:</p> <pre><code>from AlgoTree.exporters import TreeExporter\n\n# Dictionary\nd = TreeExporter.to_dict(tree)\n\n# JSON\njson_str = TreeExporter.to_json(tree, indent=2)\n\n# ASCII/Unicode\nascii_str = TreeExporter.to_ascii(tree, style=\"ascii\")\nunicode_str = TreeExporter.to_unicode(tree)\n\n# GraphViz\ndot_str = TreeExporter.to_graphviz(tree, name=\"MyTree\")\n\n# Mermaid\nmermaid_str = TreeExporter.to_mermaid(tree, direction=\"TD\")\n\n# YAML\nyaml_str = TreeExporter.to_yaml(tree, indent=2)\n\n# XML\nxml_str = TreeExporter.to_xml(tree, root_tag=\"tree\")\n\n# HTML\nhtml_str = TreeExporter.to_html(tree, collapsible=True)\n\n# Flat format\nflat_str = TreeExporter.to_flat(tree)\n</code></pre>"},{"location":"guide/export/#format-reference","title":"Format Reference","text":"Format Extension Description <code>json</code> <code>.json</code> JSON with nested structure <code>flat</code>/<code>graph</code> - Flat dictionary format <code>ascii</code> <code>.txt</code> ASCII art tree <code>unicode</code> - Unicode box-drawing tree <code>graphviz</code>/<code>dot</code> <code>.dot</code>, <code>.gv</code> GraphViz DOT format <code>mermaid</code> <code>.mmd</code> Mermaid diagram <code>yaml</code> <code>.yaml</code>, <code>.yml</code> YAML format <code>xml</code> <code>.xml</code> XML format <code>html</code> <code>.html</code> Interactive HTML"},{"location":"guide/node/","title":"Node API","text":"<p>The <code>Node</code> class is the core building block of AlgoTree. Nodes are immutable - all operations return new nodes.</p>"},{"location":"guide/node/#creating-nodes","title":"Creating Nodes","text":""},{"location":"guide/node/#basic-construction","title":"Basic Construction","text":"<pre><code>from AlgoTree import Node\n\n# Simple node\nnode = Node(\"root\")\n\n# With children\nnode = Node(\"root\",\n    Node(\"child1\"),\n    Node(\"child2\")\n)\n\n# With attributes\nnode = Node(\"root\",\n    Node(\"child1\", attrs={\"value\": 1}),\n    attrs={\"type\": \"container\"}\n)\n</code></pre>"},{"location":"guide/node/#using-the-convenience-function","title":"Using the Convenience Function","text":"<pre><code>from AlgoTree import node\n\n# kwargs become attrs, strings become nodes\ntree = node(\"root\",\n    node(\"child1\", value=1),\n    \"child2\",  # String auto-converted\n    type=\"container\"\n)\n</code></pre>"},{"location":"guide/node/#node-properties","title":"Node Properties","text":"<pre><code>node.name        # Node name (str)\nnode.children    # Child nodes (tuple)\nnode.attrs       # Attributes (dict)\nnode.is_leaf     # True if no children\nnode.is_root     # True (nodes don't track parents)\nnode.size        # Total nodes in subtree\nnode.height      # Max depth of subtree\nnode.depth       # Always 0 for standalone nodes\nnode.path        # Path string from root\n</code></pre>"},{"location":"guide/node/#accessing-attributes","title":"Accessing Attributes","text":"<pre><code># Get with default\nvalue = node.get(\"key\", default=0)\n\n# Check existence\nif \"key\" in node.attrs:\n    pass\n</code></pre>"},{"location":"guide/node/#immutable-transformations","title":"Immutable Transformations","text":"<p>All methods return new nodes - the original is never modified:</p> <pre><code>original = Node(\"root\", attrs={\"x\": 1})\n\n# Rename\nrenamed = original.with_name(\"new_name\")\n\n# Add/update attributes\nwith_attrs = original.with_attrs(y=2, z=3)\n\n# Remove attribute\nwithout = original.without_attr(\"x\")\n\n# Add child\nwith_child = original.with_child(Node(\"child\"))\n\n# Replace children\nnew_children = original.with_children(Node(\"a\"), Node(\"b\"))\n\n# Remove child\nwithout_child = original.without_child(\"child\")\n# or by index: original.without_child(0)\n</code></pre>"},{"location":"guide/node/#traversal","title":"Traversal","text":"<pre><code># Walk tree (preorder, postorder, levelorder)\nfor n in node.walk(\"preorder\"):\n    print(n.name)\n\n# Iterate children\nfor child in node.children:\n    print(child.name)\n\n# Get leaves\nfor leaf in node.leaves():\n    print(leaf.name)\n\n# Get all descendants\nfor desc in node.descendants():\n    print(desc.name)\n</code></pre>"},{"location":"guide/node/#finding-nodes","title":"Finding Nodes","text":"<pre><code># Find first match\nfound = node.find(\"child_name\")\nfound = node.find(lambda n: n.get(\"value\") &gt; 5)\n\n# Find all matches\nall_matches = node.find_all(\"pattern*\")\nall_matches = node.find_all(lambda n: n.is_leaf)\n</code></pre>"},{"location":"guide/node/#map-and-filter","title":"Map and Filter","text":"<pre><code># Map function over all nodes\ndoubled = node.map(lambda n: n.with_attrs(\n    value=n.get(\"value\", 0) * 2\n))\n\n# Filter (keeps ancestors of matching nodes)\nfiltered = node.filter(lambda n: n.get(\"value\", 0) &gt; 5)\n</code></pre>"},{"location":"guide/node/#conversion","title":"Conversion","text":"<pre><code># To dictionary\nd = node.to_dict()\n# {'name': 'root', 'children': [...], ...attrs}\n\n# From dictionary (use Tree.from_dict)\nfrom AlgoTree import Tree\ntree = Tree.from_dict({\"name\": \"root\", \"children\": [...]})\n</code></pre>"},{"location":"guide/selectors/","title":"Selectors","text":"<p>Selectors provide composable pattern matching for finding nodes in trees.</p>"},{"location":"guide/selectors/#basic-selectors","title":"Basic Selectors","text":""},{"location":"guide/selectors/#name-selector","title":"Name Selector","text":"<p>Match nodes by name, with support for wildcards and regex:</p> <pre><code>from AlgoTree import name\n\n# Exact match\nselector = name(\"config\")\n\n# Wildcard matching\nselector = name(\"*.py\")      # All .py files\nselector = name(\"test_*\")    # All test files\n\n# Regex matching\nselector = name(r\"^test_\\d+\")  # test_1, test_2, etc.\n</code></pre>"},{"location":"guide/selectors/#attribute-selector","title":"Attribute Selector","text":"<p>Match nodes by attributes:</p> <pre><code>from AlgoTree import attrs\n\n# Exact value match\nselector = attrs(type=\"file\")\n\n# Multiple attributes\nselector = attrs(type=\"file\", size=1024)\n\n# Predicate match\nselector = attrs(size=lambda s: s &gt; 500)\n\n# Check existence\nselector = attrs(metadata=None)  # Has metadata attr\n</code></pre>"},{"location":"guide/selectors/#type-selector","title":"Type Selector","text":"<p>Match nodes by type attribute:</p> <pre><code>from AlgoTree import type_\n\nselector = type_(\"directory\")\nselector = type_(\"file\")\n</code></pre>"},{"location":"guide/selectors/#predicate-selector","title":"Predicate Selector","text":"<p>Custom matching logic:</p> <pre><code>from AlgoTree import predicate\n\nselector = predicate(lambda n: n.get(\"size\", 0) &gt; 1000)\nselector = predicate(lambda n: \"test\" in n.name.lower())\n</code></pre>"},{"location":"guide/selectors/#structural-selectors","title":"Structural Selectors","text":"<pre><code>from AlgoTree import depth, leaf, root\n\n# Match by depth\nselector = depth(2)           # Nodes at depth 2\nselector = depth(range(1, 4)) # Depths 1, 2, or 3\n\n# Match leaves\nselector = leaf()\n\n# Match root\nselector = root()\n</code></pre>"},{"location":"guide/selectors/#combining-selectors","title":"Combining Selectors","text":"<p>Selectors can be combined using logical operators:</p>"},{"location":"guide/selectors/#and","title":"AND (<code>&amp;</code>)","text":"<pre><code>from AlgoTree import name, attrs, leaf\n\n# Python files that are leaves\nselector = name(\"*.py\") &amp; leaf()\n\n# Files larger than 1KB\nselector = attrs(type=\"file\") &amp; attrs(size=lambda s: s &gt; 1024)\n</code></pre>"},{"location":"guide/selectors/#or","title":"OR (<code>|</code>)","text":"<pre><code># Python or JavaScript files\nselector = name(\"*.py\") | name(\"*.js\")\n</code></pre>"},{"location":"guide/selectors/#not","title":"NOT (<code>~</code>)","text":"<pre><code># Non-leaf nodes\nselector = ~leaf()\n\n# Not test files\nselector = ~name(\"test_*\")\n</code></pre>"},{"location":"guide/selectors/#xor","title":"XOR (<code>^</code>)","text":"<pre><code># Either a or b, but not both\nselector = name(\"a\") ^ name(\"b\")\n</code></pre>"},{"location":"guide/selectors/#structural-combinators","title":"Structural Combinators","text":""},{"location":"guide/selectors/#childparent","title":"Child/Parent","text":"<pre><code>from AlgoTree import name, attrs\n\n# Files that are direct children of src\nselector = name(\"*.py\").child_of(name(\"src\"))\n\n# Directories that contain Python files\nselector = name(\"*\").parent_of(name(\"*.py\"))\n</code></pre>"},{"location":"guide/selectors/#descendantancestor","title":"Descendant/Ancestor","text":"<pre><code># Files anywhere under src\nselector = name(\"*.py\").descendant_of(name(\"src\"))\n\n# Directories that have any Python file descendants\nselector = attrs(type=\"dir\").ancestor_of(name(\"*.py\"))\n</code></pre>"},{"location":"guide/selectors/#sibling","title":"Sibling","text":"<pre><code># Nodes that have a README sibling\nselector = name(\"*\").sibling_of(name(\"README*\"))\n</code></pre>"},{"location":"guide/selectors/#at-depth","title":"At Depth","text":"<pre><code># Python files at depth 3\nselector = name(\"*.py\").at_depth(3)\n</code></pre>"},{"location":"guide/selectors/#where-add-constraints","title":"Where (Add Constraints)","text":"<pre><code># Files with specific attributes\nselector = name(\"*.py\").where(size=lambda s: s &gt; 0)\n</code></pre>"},{"location":"guide/selectors/#using-selectors","title":"Using Selectors","text":""},{"location":"guide/selectors/#with-selector-methods","title":"With Selector Methods","text":"<pre><code>selector = name(\"*.py\") &amp; leaf()\n\n# Select all matching nodes\nfor node in selector.select(tree):\n    print(node.name)\n\n# Get first match\nfirst = selector.first(tree)\n\n# Count matches\ncount = selector.count(tree)\n\n# Check existence\nif selector.exists(tree):\n    print(\"Found matching nodes\")\n</code></pre>"},{"location":"guide/selectors/#with-tree-methods","title":"With Tree Methods","text":"<pre><code>from AlgoTree import Tree, name, leaf\n\ntree = Tree(...)\n\n# Find with selector\nnodes = tree.find_all(name(\"*.py\") &amp; leaf())\n\n# Filter with selector\nfiltered = tree.filter(name(\"*.py\"))\n</code></pre>"},{"location":"guide/selectors/#css-like-selector-parser","title":"CSS-like Selector Parser","text":"<p>Parse CSS-like selector strings:</p> <pre><code>from AlgoTree.selectors import parse\n\n# By name\nselector = parse(\"config\")\n\n# Wildcard\nselector = parse(\"*.txt\")\n\n# Attribute\nselector = parse(\"[type=file]\")\n\n# Direct child\nselector = parse(\"src &gt; main.py\")\n\n# Descendant\nselector = parse(\"src main.py\")\n\n# Pseudo-selectors\nselector = parse(\":leaf\")\nselector = parse(\":root\")\n</code></pre>"},{"location":"guide/selectors/#selector-reference","title":"Selector Reference","text":"Selector Description <code>name(pattern)</code> Match by name <code>attrs(**kw)</code> Match by attributes <code>type_(t)</code> Match by type attribute <code>predicate(fn)</code> Custom predicate <code>depth(d)</code> Match by depth <code>leaf()</code> Match leaf nodes <code>root()</code> Match root node <code>any_()</code> Match all nodes <code>none()</code> Match no nodes"},{"location":"guide/transformers/","title":"Transformers","text":"<p>Transformers provide composable, reusable tree operations that can be chained together using operators.</p>"},{"location":"guide/transformers/#tree-transformers","title":"Tree Transformers","text":"<p>These transform a tree into another tree.</p>"},{"location":"guide/transformers/#map-transformer","title":"Map Transformer","text":"<p>Apply a function to all nodes:</p> <pre><code>from AlgoTree import map_\n\n# Add attribute to all nodes\ntransformer = map_(lambda n: n.with_attrs(processed=True))\n\n# Double all values\ntransformer = map_(lambda n: n.with_attrs(\n    value=n.get(\"value\", 0) * 2\n))\n\nresult = transformer(tree)\n</code></pre>"},{"location":"guide/transformers/#filter-transformer","title":"Filter Transformer","text":"<p>Keep nodes matching a predicate:</p> <pre><code>from AlgoTree import filter_\nfrom AlgoTree import leaf, name\n\n# Keep only leaves\ntransformer = filter_(leaf())\n\n# Keep Python files\ntransformer = filter_(name(\"*.py\"))\n\n# Keep nodes with size &gt; 100\ntransformer = filter_(lambda n: n.get(\"size\", 0) &gt; 100)\n</code></pre>"},{"location":"guide/transformers/#prune-transformer","title":"Prune Transformer","text":"<p>Remove nodes matching a selector:</p> <pre><code>from AlgoTree import prune\n\n# Remove temp directories\ntransformer = prune(\"temp*\")\n\n# Remove hidden files\ntransformer = prune(lambda n: n.name.startswith(\".\"))\n</code></pre>"},{"location":"guide/transformers/#graft-transformer","title":"Graft Transformer","text":"<p>Add subtrees to matching nodes:</p> <pre><code>from AlgoTree import graft, Node\n\n# Add utils to src directory\ntransformer = graft(\"src\", Node(\"utils\"))\n\n# Dynamic graft based on node\ntransformer = graft(\n    \"src\",\n    lambda n: Node(f\"{n.name}_backup\")\n)\n</code></pre>"},{"location":"guide/transformers/#flatten-transformer","title":"Flatten Transformer","text":"<p>Flatten tree to specified depth:</p> <pre><code>from AlgoTree import flatten\n\n# Flatten to depth 2\ntransformer = flatten(max_depth=2)\n</code></pre>"},{"location":"guide/transformers/#normalize-transformer","title":"Normalize Transformer","text":"<p>Sort children and clean attributes:</p> <pre><code>from AlgoTree import normalize\n\n# Sort children by name\ntransformer = normalize(sort_children=True)\n\n# Sort with custom key\ntransformer = normalize(\n    sort_children=True,\n    sort_key=lambda n: n.get(\"priority\", 0)\n)\n\n# Clean attributes\ntransformer = normalize(\n    clean_attrs=True,\n    allowed_attrs=[\"name\", \"type\"]\n)\n</code></pre>"},{"location":"guide/transformers/#annotate-transformer","title":"Annotate Transformer","text":"<p>Add annotations to nodes:</p> <pre><code>from AlgoTree import annotate\n\n# Add to all nodes\ntransformer = annotate(visited=True)\n\n# Add to selected nodes\ntransformer = annotate(\n    \"*.py\",\n    file_type=\"python\",\n    size=lambda n: len(n.name)\n)\n</code></pre>"},{"location":"guide/transformers/#shapers-tree-to-value","title":"Shapers (Tree to Value)","text":"<p>These transform a tree into a different type.</p>"},{"location":"guide/transformers/#reduce-shaper","title":"Reduce Shaper","text":"<p>Reduce tree to single value:</p> <pre><code>from AlgoTree import reduce_\n\n# Count total size\ntransformer = reduce_(\n    lambda acc, n: acc + n.get(\"size\", 0),\n    initial=0\n)\n\n# Collect all names\ntransformer = reduce_(\n    lambda acc, n: acc + [n.name],\n    initial=[],\n    order=\"postorder\"\n)\n</code></pre>"},{"location":"guide/transformers/#fold-shaper","title":"Fold Shaper","text":"<p>Bottom-up fold:</p> <pre><code>from AlgoTree import fold\n\n# Calculate subtree sizes\ntransformer = fold(\n    lambda node, child_results: 1 + sum(child_results)\n)\n\n# Calculate max depth\ntransformer = fold(\n    lambda node, child_results: (\n        1 + max(child_results) if child_results else 0\n    )\n)\n</code></pre>"},{"location":"guide/transformers/#extract-shaper","title":"Extract Shaper","text":"<p>Extract values from nodes:</p> <pre><code>from AlgoTree import extract\n\n# Extract all names\ntransformer = extract(lambda n: n.name)\n\n# Extract from selected nodes\ntransformer = extract(\n    lambda n: n.get(\"size\"),\n    selector=\"*.py\"\n)\n</code></pre>"},{"location":"guide/transformers/#to-dict-shaper","title":"To Dict Shaper","text":"<p>Convert to dictionary:</p> <pre><code>from AlgoTree import to_dict\n\ntransformer = to_dict(children_key=\"children\")\nresult = transformer(tree)\n</code></pre>"},{"location":"guide/transformers/#to-paths-shaper","title":"To Paths Shaper","text":"<p>Convert to list of paths:</p> <pre><code>from AlgoTree import to_paths\n\ntransformer = to_paths(delimiter=\"/\", to_leaves_only=True)\npaths = transformer(tree)\n</code></pre>"},{"location":"guide/transformers/#composing-transformers","title":"Composing Transformers","text":""},{"location":"guide/transformers/#pipeline-or","title":"Pipeline (<code>&gt;&gt;</code> or <code>|</code>)","text":"<p>Chain transformers sequentially:</p> <pre><code>from AlgoTree import map_, filter_, prune\n\n# Using &gt;&gt; operator\npipeline = (\n    prune(\"temp*\")\n    &gt;&gt; filter_(lambda n: n.get(\"size\", 0) &gt; 0)\n    &gt;&gt; map_(lambda n: n.with_attrs(processed=True))\n)\n\n# Using | operator\npipeline = (\n    prune(\"temp*\")\n    | filter_(lambda n: n.get(\"size\", 0) &gt; 0)\n    | map_(lambda n: n.with_attrs(processed=True))\n)\n\nresult = pipeline(tree)\n</code></pre>"},{"location":"guide/transformers/#parallel","title":"Parallel (<code>&amp;</code>)","text":"<p>Apply multiple transformers and merge:</p> <pre><code>from AlgoTree import map_\n\n# Apply both transformers\ntransformer = (\n    map_(lambda n: n.with_attrs(a=1))\n    &amp; map_(lambda n: n.with_attrs(b=2))\n)\n</code></pre>"},{"location":"guide/transformers/#repeat","title":"Repeat","text":"<p>Apply a transformer multiple times:</p> <pre><code>from AlgoTree import prune\n\n# Prune 3 times\ntransformer = prune(\"empty*\").repeat(3)\n</code></pre>"},{"location":"guide/transformers/#conditional","title":"Conditional","text":"<p>Apply transformer only when condition is met:</p> <pre><code>from AlgoTree import map_\n\ntransformer = map_(\n    lambda n: n.with_attrs(large=True)\n).when(lambda t: t.size &gt; 100)\n</code></pre>"},{"location":"guide/transformers/#debug","title":"Debug","text":"<p>Add debugging to see intermediate results:</p> <pre><code>from AlgoTree import map_, filter_\n\npipeline = (\n    filter_(lambda n: n.depth &gt; 0).debug(\"after_filter\")\n    &gt;&gt; map_(lambda n: n.with_attrs(done=True)).debug(\"after_map\")\n)\n</code></pre>"},{"location":"guide/transformers/#using-with-trees","title":"Using with Trees","text":""},{"location":"guide/transformers/#direct-application","title":"Direct Application","text":"<pre><code>from AlgoTree import Tree, Node, map_\n\ntree = Tree(Node(\"root\", Node(\"a\"), Node(\"b\")))\ntransformer = map_(lambda n: n.with_attrs(visited=True))\n\nresult = transformer(tree)\n</code></pre>"},{"location":"guide/transformers/#pipe-operator","title":"Pipe Operator","text":"<pre><code>from AlgoTree import Tree, map_, filter_\n\nresult = tree | map_(lambda n: {...})\nresult = tree &gt;&gt; map_(...) &gt;&gt; filter_(...)\n</code></pre>"},{"location":"guide/transformers/#transformer-reference","title":"Transformer Reference","text":""},{"location":"guide/transformers/#tree-transformers_1","title":"Tree Transformers","text":"Transformer Description <code>map_(fn)</code> Map function over nodes <code>filter_(pred)</code> Keep matching nodes <code>prune(sel)</code> Remove matching nodes <code>graft(sel, subtree)</code> Add subtree to matches <code>flatten(depth)</code> Flatten to max depth <code>normalize(**opts)</code> Sort/clean tree <code>annotate(sel, **attrs)</code> Add annotations"},{"location":"guide/transformers/#shapers","title":"Shapers","text":"Shaper Description <code>reduce_(fn, init)</code> Reduce to value <code>fold(fn)</code> Bottom-up fold <code>extract(fn, sel)</code> Extract from nodes <code>to_dict(key)</code> Convert to dict <code>to_paths(delim)</code> Convert to paths"},{"location":"guide/tree/","title":"Tree API","text":"<p>The <code>Tree</code> class wraps a <code>Node</code> and provides additional functional operations.</p>"},{"location":"guide/tree/#creating-trees","title":"Creating Trees","text":"<pre><code>from AlgoTree import Tree, Node\n\n# From Node\ntree = Tree(Node(\"root\", Node(\"a\"), Node(\"b\")))\n\n# From string (creates single node)\ntree = Tree(\"root\")\n\n# From dictionary\ntree = Tree.from_dict({\n    \"name\": \"root\",\n    \"value\": 1,\n    \"children\": [\n        {\"name\": \"a\", \"value\": 2},\n        {\"name\": \"b\", \"value\": 3}\n    ]\n})\n\n# From paths\ntree = Tree.from_paths([\n    \"root/src/main.py\",\n    \"root/src/utils.py\",\n    \"root/docs/README.md\"\n])\n</code></pre>"},{"location":"guide/tree/#properties","title":"Properties","text":"<pre><code>tree.root      # Root Node\ntree.size      # Total node count\ntree.height    # Tree height (max depth)\ntree.leaves    # List of leaf nodes\ntree.is_empty  # True if empty tree\n</code></pre>"},{"location":"guide/tree/#functional-operations","title":"Functional Operations","text":""},{"location":"guide/tree/#map","title":"Map","text":"<pre><code># Map function over all nodes\nmapped = tree.map(lambda n: {\"processed\": True})\n\n# Map can return:\n# - dict: updates node attrs\n# - Node: replaces node\n# - None: keeps node unchanged\n</code></pre>"},{"location":"guide/tree/#filter","title":"Filter","text":"<pre><code># Keep nodes matching predicate\n# Note: preserves ancestors of matching nodes\nfiltered = tree.filter(lambda n: n.get(\"value\", 0) &gt; 5)\n</code></pre>"},{"location":"guide/tree/#reduce","title":"Reduce","text":"<pre><code># Reduce to single value\ntotal = tree.reduce(\n    lambda acc, node: acc + node.get(\"value\", 0),\n    initial=0,\n    order=\"preorder\"\n)\n</code></pre>"},{"location":"guide/tree/#fold","title":"Fold","text":"<pre><code># Bottom-up fold\nsizes = tree.fold(lambda node, child_results: 1 + sum(child_results))\n</code></pre>"},{"location":"guide/tree/#structure-operations","title":"Structure Operations","text":""},{"location":"guide/tree/#prune","title":"Prune","text":"<pre><code># Remove matching nodes\npruned = tree.prune(\"temp*\")\npruned = tree.prune(lambda n: n.name.startswith(\".\"))\n</code></pre>"},{"location":"guide/tree/#graft","title":"Graft","text":"<pre><code># Add subtree to matching nodes\ngrafted = tree.graft(\"lib\", Node(\"utils\", Node(\"helpers\")))\n</code></pre>"},{"location":"guide/tree/#flatten","title":"Flatten","text":"<pre><code># Flatten to max depth\nflattened = tree.flatten(max_depth=2)\n</code></pre>"},{"location":"guide/tree/#query-operations","title":"Query Operations","text":"<pre><code># Find first match\nnode = tree.find(\"config\")\nnode = tree.find(lambda n: n.get(\"type\") == \"file\")\n\n# Find all matches\nnodes = tree.find_all(\"*.py\")\nnodes = tree.find_all(lambda n: n.is_leaf)\n\n# Check existence\nif tree.exists(\"config\"):\n    pass\n\n# Count matches\ncount = tree.count(lambda n: n.is_leaf)\n\n# Select (returns iterator)\nfor node in tree.select(\"*.py\"):\n    print(node.name)\n</code></pre>"},{"location":"guide/tree/#path-operations","title":"Path Operations","text":"<pre><code># Get node at path\nnode = tree.get_path(\"root/src/main.py\")\n\n# Get all paths\npaths = tree.paths(to_leaves_only=True)\n</code></pre>"},{"location":"guide/tree/#export","title":"Export","text":"<pre><code># To dictionary\nd = tree.to_dict()\n\n# To paths\npaths = tree.to_paths()\n</code></pre>"},{"location":"guide/tree/#operators","title":"Operators","text":"<pre><code>from AlgoTree import map_, filter_\n\n# Pipe through transformer\nresult = tree | map_(lambda n: {\"tagged\": True})\n\n# Chain transformers\nresult = tree &gt;&gt; map_(...) &gt;&gt; filter_(...)\n</code></pre>"},{"location":"interop/algograph/","title":"AlgoGraph Interoperability","text":"<p>AlgoTree provides seamless interoperability with AlgoGraph, enabling conversion between tree and graph representations.</p>"},{"location":"interop/algograph/#installation","title":"Installation","text":"<p>AlgoGraph is an optional dependency:</p> <pre><code>pip install AlgoGraph\n</code></pre>"},{"location":"interop/algograph/#converting-trees-to-graphs","title":"Converting Trees to Graphs","text":"<p>Use <code>tree_to_graph()</code> to convert a tree to a graph:</p> <pre><code>from AlgoTree import Node, tree_to_graph\n\n# Create a tree\ntree = Node('root',\n    Node('child1', attrs={'value': 10}),\n    Node('child2', attrs={'value': 20})\n)\n\n# Convert to graph\ngraph = tree_to_graph(tree)\n\n# The graph contains all nodes as vertices\nprint(graph.vertex_count)  # 3\n\n# And parent-child edges\nprint(graph.edge_count)    # 2\n</code></pre>"},{"location":"interop/algograph/#options","title":"Options","text":"<pre><code># Directed edges (default)\ngraph = tree_to_graph(tree, directed=True)\n\n# Undirected edges\ngraph = tree_to_graph(tree, directed=False)\n</code></pre>"},{"location":"interop/algograph/#converting-graphs-to-trees","title":"Converting Graphs to Trees","text":"<p>Use <code>graph_to_tree()</code> to extract a spanning tree from a graph:</p> <pre><code>from AlgoGraph import Graph, Vertex, Edge\nfrom AlgoTree import graph_to_tree\n\n# Create a graph\nv1, v2, v3 = Vertex('A'), Vertex('B'), Vertex('C')\ne1, e2 = Edge('A', 'B'), Edge('A', 'C')\ngraph = Graph({v1, v2, v3}, {e1, e2})\n\n# Convert to tree (specify root)\ntree = graph_to_tree(graph, 'A')\n\nprint(tree.name)          # 'A'\nprint(len(tree.children)) # 2\n</code></pre>"},{"location":"interop/algograph/#notes-on-graph-to-tree-conversion","title":"Notes on Graph-to-Tree Conversion","text":"<ul> <li>Requires specifying a root vertex</li> <li>Uses BFS traversal to build spanning tree</li> <li>Cycles in the graph are broken</li> <li>All vertices reachable from root are included</li> </ul>"},{"location":"interop/algograph/#flat-dictionary-format","title":"Flat Dictionary Format","text":"<p>Both libraries support a flat dictionary format for interoperability:</p>"},{"location":"interop/algograph/#tree-to-flat-dict","title":"Tree to Flat Dict","text":"<pre><code>from AlgoTree import Node, node_to_flat_dict\n\ntree = Node('A',\n    Node('B'),\n    Node('C', attrs={'value': 10})\n)\n\nflat = node_to_flat_dict(tree)\n# {\n#   'A': {'.name': 'A', '.children': ['B', 'C']},\n#   'A/B': {'.name': 'B', '.children': []},\n#   'A/C': {'.name': 'C', '.children': [], 'value': 10}\n# }\n</code></pre>"},{"location":"interop/algograph/#flat-dict-to-tree","title":"Flat Dict to Tree","text":"<pre><code>from AlgoTree import flat_dict_to_node\n\nflat = {\n    'A': {'.name': 'A', '.children': ['B', 'C'], 'value': 10},\n    'B': {'.name': 'B', '.children': []},\n    'C': {'.name': 'C', '.children': []}\n}\n\ntree = flat_dict_to_node(flat, root_key='A')\nprint(tree.name)  # 'A'\nprint(tree.get('value'))  # 10\n</code></pre>"},{"location":"interop/algograph/#auto-detecting-root","title":"Auto-detecting Root","text":"<pre><code># Root is auto-detected if not specified\ntree = flat_dict_to_node(flat)\n</code></pre>"},{"location":"interop/algograph/#tree-wrapper-functions","title":"Tree Wrapper Functions","text":"<p>For <code>Tree</code> objects:</p> <pre><code>from AlgoTree import Tree, tree_to_flat_dict, flat_dict_to_tree\n\ntree = Tree(Node('root', Node('a'), Node('b')))\n\n# To flat dict\nflat = tree_to_flat_dict(tree)\n\n# From flat dict\ntree = flat_dict_to_tree(flat)\n</code></pre>"},{"location":"interop/algograph/#format-details","title":"Format Details","text":"<p>The flat dictionary format uses:</p> <ul> <li>Keys: Node identifiers (with path prefix for duplicates)</li> <li><code>.name</code>: Original node name</li> <li><code>.children</code>: List of child node names</li> <li>Other keys: Node attributes</li> </ul> <p>Example: <pre><code>{\n  \"root\": {\n    \".name\": \"root\",\n    \".children\": [\"child1\", \"child2\"],\n    \"type\": \"directory\"\n  },\n  \"root/child1\": {\n    \".name\": \"child1\",\n    \".children\": [],\n    \"type\": \"file\"\n  },\n  \"root/child2\": {\n    \".name\": \"child2\",\n    \".children\": [],\n    \"type\": \"file\"\n  }\n}\n</code></pre></p>"},{"location":"interop/algograph/#round-trip-conversion","title":"Round-Trip Conversion","text":"<p>Trees can be converted to graphs and back:</p> <pre><code>from AlgoTree import Node, tree_to_graph, graph_to_tree\n\n# Original tree\noriginal = Node('root',\n    Node('a', attrs={'value': 1}),\n    Node('b', attrs={'value': 2})\n)\n\n# Convert to graph and back\ngraph = tree_to_graph(original)\nrecovered = graph_to_tree(graph, 'root')\n\n# Structure and attributes preserved\nassert recovered.name == original.name\nassert len(recovered.children) == len(original.children)\n</code></pre>"},{"location":"interop/algograph/#use-cases","title":"Use Cases","text":""},{"location":"interop/algograph/#graph-algorithms-on-trees","title":"Graph Algorithms on Trees","text":"<pre><code>from AlgoTree import tree_to_graph\n\n# Convert tree to graph for graph algorithms\ngraph = tree_to_graph(tree)\n\n# Use AlgoGraph's algorithms\nshortest_path = graph.shortest_path('root', 'leaf')\nconnected = graph.is_connected()\n</code></pre>"},{"location":"interop/algograph/#tree-view-of-graphs","title":"Tree View of Graphs","text":"<pre><code>from AlgoTree import graph_to_tree, pretty_tree\n\n# Extract spanning tree from graph\ntree = graph_to_tree(graph, 'start_node')\n\n# Visualize as tree\nprint(pretty_tree(tree))\n</code></pre>"},{"location":"interop/algograph/#data-exchange","title":"Data Exchange","text":"<pre><code>from AlgoTree import node_to_flat_dict, flat_dict_to_node\nimport json\n\n# Serialize tree\nflat = node_to_flat_dict(tree)\njson_str = json.dumps(flat)\n\n# Deserialize\nflat = json.loads(json_str)\ntree = flat_dict_to_node(flat)\n</code></pre>"},{"location":"interop/algograph/#api-reference","title":"API Reference","text":"Function Description <code>tree_to_graph(node, directed)</code> Convert tree to AlgoGraph <code>graph_to_tree(graph, root_id)</code> Extract tree from graph <code>node_to_flat_dict(node)</code> Convert node to flat dict <code>flat_dict_to_node(flat, root)</code> Convert flat dict to node <code>tree_to_flat_dict(tree)</code> Convert Tree to flat dict <code>flat_dict_to_tree(flat, root)</code> Convert flat dict to Tree"},{"location":"migration/v1-to-v2/","title":"Migration Guide: v1.x to v2.0","text":"<p>AlgoTree v2.0 introduces a modern, immutable-by-default API. This guide helps you migrate from v1.x.</p>"},{"location":"migration/v1-to-v2/#key-changes","title":"Key Changes","text":""},{"location":"migration/v1-to-v2/#1-immutability","title":"1. Immutability","text":"<p>v1.x (Mutable): <pre><code># Nodes were mutable\nnode = TreeNode(name=\"x\")\nnode.add_child(child)  # Modified node in place\nnode.foo = \"bar\"       # Direct attribute assignment\n</code></pre></p> <p>v2.0 (Immutable): <pre><code># All operations return new nodes\nnode = Node(\"x\")\nnode = node.with_child(child)       # Returns new node\nnode = node.with_attrs(foo=\"bar\")   # Returns new node\n</code></pre></p>"},{"location":"migration/v1-to-v2/#2-node-construction","title":"2. Node Construction","text":"<p>v1.x: <pre><code>node = TreeNode(name=\"x\", foo=\"bar\", baz=123)\n</code></pre></p> <p>v2.0: <pre><code># Attributes go in explicit attrs dict\nnode = Node(\"x\", attrs={\"foo\": \"bar\", \"baz\": 123})\n\n# Or use convenience function\nnode = node(\"x\", foo=\"bar\", baz=123)\n</code></pre></p>"},{"location":"migration/v1-to-v2/#3-adding-children","title":"3. Adding Children","text":"<p>v1.x: <pre><code>parent.add_child(child)\nparent.children.append(child)\n</code></pre></p> <p>v2.0: <pre><code>parent = parent.with_child(child)\nparent = parent.with_children(child1, child2, child3)\n</code></pre></p>"},{"location":"migration/v1-to-v2/#4-removing-children","title":"4. Removing Children","text":"<p>v1.x: <pre><code>parent.remove_child(child)\ndel parent.children[0]\n</code></pre></p> <p>v2.0: <pre><code>parent = parent.without_child(\"child_name\")\nparent = parent.without_child(0)  # By index\n</code></pre></p>"},{"location":"migration/v1-to-v2/#5-modifying-attributes","title":"5. Modifying Attributes","text":"<p>v1.x: <pre><code>node.value = 10\nnode.type = \"file\"\ndel node.some_attr\n</code></pre></p> <p>v2.0: <pre><code>node = node.with_attrs(value=10, type=\"file\")\nnode = node.without_attr(\"some_attr\")\n</code></pre></p>"},{"location":"migration/v1-to-v2/#6-renaming-nodes","title":"6. Renaming Nodes","text":"<p>v1.x: <pre><code>node.name = \"new_name\"\n</code></pre></p> <p>v2.0: <pre><code>node = node.with_name(\"new_name\")\n</code></pre></p>"},{"location":"migration/v1-to-v2/#api-mapping","title":"API Mapping","text":"v1.x v2.0 <code>TreeNode(name, **kwargs)</code> <code>Node(name, attrs={...})</code> <code>node.add_child(child)</code> <code>node.with_child(child)</code> <code>node.remove_child(child)</code> <code>node.without_child(child)</code> <code>node.name = x</code> <code>node.with_name(x)</code> <code>node.foo = x</code> <code>node.with_attrs(foo=x)</code> <code>del node.foo</code> <code>node.without_attr(\"foo\")</code> <code>node.children.append(x)</code> <code>node.with_child(x)</code> <code>node.foo</code> <code>node.get(\"foo\")</code>"},{"location":"migration/v1-to-v2/#tree-class-changes","title":"Tree Class Changes","text":""},{"location":"migration/v1-to-v2/#v1x-tree","title":"v1.x Tree","text":"<pre><code>from AlgoTree import FlatForest\n\nforest = FlatForest()\nforest.add_node(\"root\")\nforest.add_node(\"child\", parent=\"root\")\n</code></pre>"},{"location":"migration/v1-to-v2/#v20-tree","title":"v2.0 Tree","text":"<pre><code>from AlgoTree import Tree, Node\n\ntree = Tree(Node(\"root\", Node(\"child\")))\n\n# Factory methods\ntree = Tree.from_dict({\"name\": \"root\", \"children\": [...]})\ntree = Tree.from_paths([\"a/b/c\", \"a/b/d\"])\n</code></pre>"},{"location":"migration/v1-to-v2/#new-features-in-v20","title":"New Features in v2.0","text":""},{"location":"migration/v1-to-v2/#selectors","title":"Selectors","text":"<p>Composable pattern matching:</p> <pre><code>from AlgoTree import name, attrs, leaf\n\n# Combine with operators\nselector = name(\"*.py\") &amp; leaf()\nnodes = tree.find_all(selector)\n</code></pre>"},{"location":"migration/v1-to-v2/#transformers","title":"Transformers","text":"<p>Reusable tree operations:</p> <pre><code>from AlgoTree import map_, filter_, prune\n\npipeline = map_(fn) &gt;&gt; filter_(pred) &gt;&gt; prune(selector)\nresult = pipeline(tree)\n</code></pre>"},{"location":"migration/v1-to-v2/#pipe-operators","title":"Pipe Operators","text":"<pre><code>result = tree | map_(fn)\nresult = tree &gt;&gt; map_(fn) &gt;&gt; filter_(pred)\n</code></pre>"},{"location":"migration/v1-to-v2/#dsl-parsing","title":"DSL Parsing","text":"<pre><code>from AlgoTree import parse_tree\n\ntree = parse_tree(\"\"\"\nroot\n\u251c\u2500\u2500 child1\n\u2514\u2500\u2500 child2\n\"\"\")\n</code></pre>"},{"location":"migration/v1-to-v2/#export-formats","title":"Export Formats","text":"<pre><code>from AlgoTree import export_tree, save_tree\n\ndot = export_tree(tree, \"graphviz\")\nsave_tree(tree, \"tree.json\")\n</code></pre>"},{"location":"migration/v1-to-v2/#migration-patterns","title":"Migration Patterns","text":""},{"location":"migration/v1-to-v2/#pattern-1-building-trees","title":"Pattern 1: Building Trees","text":"<p>Before: <pre><code>root = TreeNode(\"root\")\nchild1 = TreeNode(\"child1\", value=10)\nchild2 = TreeNode(\"child2\", value=20)\nroot.add_child(child1)\nroot.add_child(child2)\n</code></pre></p> <p>After: <pre><code>root = Node(\"root\",\n    Node(\"child1\", attrs={\"value\": 10}),\n    Node(\"child2\", attrs={\"value\": 20})\n)\n</code></pre></p>"},{"location":"migration/v1-to-v2/#pattern-2-modifying-trees","title":"Pattern 2: Modifying Trees","text":"<p>Before: <pre><code>for node in tree.walk():\n    node.visited = True\n</code></pre></p> <p>After: <pre><code>tree = tree.map(lambda n: n.with_attrs(visited=True))\n</code></pre></p>"},{"location":"migration/v1-to-v2/#pattern-3-filtering","title":"Pattern 3: Filtering","text":"<p>Before: <pre><code>result = []\nfor node in tree.walk():\n    if node.value &gt; 10:\n        result.append(node)\n</code></pre></p> <p>After: <pre><code>result = tree.find_all(lambda n: n.get(\"value\", 0) &gt; 10)\n# Or\nresult = tree.filter(lambda n: n.get(\"value\", 0) &gt; 10)\n</code></pre></p>"},{"location":"migration/v1-to-v2/#pattern-4-transformations","title":"Pattern 4: Transformations","text":"<p>Before: <pre><code>def transform(node):\n    node.value = node.value * 2\n    for child in node.children:\n        transform(child)\n</code></pre></p> <p>After: <pre><code>tree = tree.map(lambda n: n.with_attrs(\n    value=n.get(\"value\", 0) * 2\n))\n</code></pre></p>"},{"location":"migration/v1-to-v2/#compatibility-layer","title":"Compatibility Layer","text":"<p>If you need to maintain v1.x compatibility during migration, you can create wrapper functions:</p> <pre><code>def add_child(parent, child):\n    \"\"\"v1.x-style add_child as function.\"\"\"\n    return parent.with_child(child)\n\ndef set_attr(node, key, value):\n    \"\"\"v1.x-style attribute setting.\"\"\"\n    return node.with_attrs(**{key: value})\n</code></pre>"},{"location":"migration/v1-to-v2/#benefits-of-v20","title":"Benefits of v2.0","text":"<ol> <li>Predictability: Immutable data is easier to reason about</li> <li>Thread Safety: No shared mutable state</li> <li>Functional Composition: Pipeline operators for clean code</li> <li>Better Testing: Pure functions are easy to test</li> <li>Undo/History: Keep old versions for free</li> <li>Type Safety: Better IDE support with type hints</li> </ol>"},{"location":"migration/v1-to-v2/#getting-help","title":"Getting Help","text":"<ul> <li>Full API Documentation</li> <li>GitHub Issues</li> </ul>"}]}