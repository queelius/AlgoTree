<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>FlatForest Notebook &#8212; AlgoTree 0.8.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=27fed22d" />
    <script src="_static/documentation_options.js?v=486e5634"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Expression Trees and Evaluation" href="expr_trees_nb.html" />
    <link rel="prev" title="AlgoTree: Comprehensive Tutorial" href="tutorial.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="flatforest-notebook">
<h1>FlatForest Notebook<a class="headerlink" href="#flatforest-notebook" title="Link to this heading">¶</a></h1>
<nav class="contents" id="table-of-contents">
<p class="topic-title">Table of Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#flatforest-notebook" id="id1">FlatForest Notebook</a></p>
<ul>
<li><p><a class="reference internal" href="#introduction" id="id2">Introduction</a></p></li>
<li><p><a class="reference internal" href="#creating-a-flatforest" id="id3">Creating a <code class="docutils literal notranslate"><span class="pre">FlatForest</span></code></a></p>
<ul>
<li><p><a class="reference internal" href="#output" id="id4">Output</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#storing-and-transmitting-trees" id="id5">Storing and Transmitting Trees</a></p>
<ul>
<li><p><a class="reference internal" href="#creating-a-flatforest-from-a-json" id="id6">Creating a <cite>FlatForest</cite> from a JSON</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#algorithm-examples" id="id7">Algorithm Examples</a></p></li>
<li><p><a class="reference internal" href="#conclusion" id="id8">Conclusion</a></p></li>
</ul>
</li>
</ul>
</nav>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p>In this notebook, we explore the <code class="docutils literal notranslate"><span class="pre">FlatForest</span></code> data structure, which is
a forest structure with a flat (non-nested) data structure. It is a
<code class="docutils literal notranslate"><span class="pre">dict</span></code> with special methods to access the root nodes and other
tree-like operations.</p>
<p>The main implementation detail is the proxy class <code class="docutils literal notranslate"><span class="pre">FlatForestNode</span></code>,
which allows us to access the <code class="docutils literal notranslate"><span class="pre">dict</span></code> with a node-centric abstraction.
This allows us to implement tree-like operations in a flat data
structure. As a proxy, it also modifies the <code class="docutils literal notranslate"><span class="pre">dict</span></code> in place, so it is
a mutable data structure.</p>
</section>
<section id="creating-a-flatforest">
<h2>Creating a <code class="docutils literal notranslate"><span class="pre">FlatForest</span></code><a class="headerlink" href="#creating-a-flatforest" title="Link to this heading">¶</a></h2>
<p>Let’s load the required libraries and create a <code class="docutils literal notranslate"><span class="pre">FlatForest</span></code> data
structure using the node interface.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>from AlgoTree.flat_forest_node import FlatForestNode
from AlgoTree.flat_forest import FlatForest
from AlgoTree.tree_converter import TreeConverter
from IPython.display import display, Markdown
from AlgoTree.pretty_tree import pretty_tree
import json
#from AlgoTree.treenode import TreeNode
from copy import deepcopy


def monotext(txt):
    display(Markdown(f&quot;&lt;pre&gt;{txt}&lt;/pre&gt;&quot;))

data = {
    &quot;1&quot;: { &quot;data&quot;: 1, &quot;parent&quot;: None},
    &quot;2&quot;: { &quot;parent&quot;: &quot;1&quot;, &quot;data&quot;: 2},
    &quot;3&quot;: { &quot;parent&quot;: &quot;1&quot;, &quot;data&quot;: 3},
    &quot;4&quot;: { &quot;parent&quot;: &quot;3&quot;, &quot;data&quot;: 4},
    &quot;5&quot;: { &quot;parent&quot;: &quot;3&quot;, &quot;data&quot;: 5},
    &quot;A&quot;: { &quot;data&quot;: &quot;Data for A&quot;, &quot;parent&quot;: None },
    &quot;B&quot;: { &quot;parent&quot;: &quot;A&quot;, &quot;data&quot;: &quot;Data for B&quot; },
    &quot;C&quot;: { &quot;parent&quot;: &quot;A&quot;, &quot;data&quot;: &quot;Data for C&quot; },
    &quot;D&quot;: { &quot;parent&quot;: &quot;C&quot;, &quot;data&quot;: &quot;Data for D&quot; },
    &quot;E&quot;: { &quot;parent&quot;: &quot;C&quot;, &quot;data&quot;: &quot;Data for E&quot; },
    &quot;F&quot;: { &quot;parent&quot;: &quot;E&quot;, &quot;data&quot;: &quot;Data for F&quot; },
    &quot;G&quot;: { &quot;parent&quot;: &quot;E&quot;, &quot;data&quot;: &quot;Data for G&quot; },
    &quot;H&quot;: { &quot;parent&quot;: &quot;B&quot;, &quot;data&quot;: &quot;Data for H&quot; },
    &quot;I&quot;: { &quot;parent&quot;: &quot;A&quot;, &quot;data&quot;: &quot;Data for I&quot; },
    &quot;J&quot;: { &quot;parent&quot;: &quot;I&quot;, &quot;data&quot;: &quot;Data for J&quot; },
    &quot;K&quot;: { &quot;parent&quot;: &quot;G&quot;, &quot;data&quot;: &quot;Data for K&quot; },
    &quot;L&quot;: { &quot;parent&quot;: &quot;G&quot;, &quot;data&quot;: &quot;Data for L&quot; },
    &quot;M&quot;: { &quot;parent&quot;: &quot;C&quot;, &quot;data&quot;: &quot;Data for M&quot; },
}

forest = FlatForest()
nodes = []
for key, value in data.items():
    par_key = value.pop(&quot;parent&quot;, None)
    nodes.append(FlatForestNode(name=key, parent=par_key, forest=forest, data=value[&quot;data&quot;]))

for node in nodes:
    try:
        print(node.name, node.payload, node.parent.name if node.parent is not None else None)
    except ValueError as e:
        print(f&quot;ValueError: {e}&quot;)
    except KeyError as e:
        print(f&quot;KeyError: {e}&quot;)
    print()
</pre></div>
</div>
<section id="output">
<h3>Output<a class="headerlink" href="#output" title="Link to this heading">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span> <span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span> <span class="kc">None</span>

<span class="mi">2</span> <span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span> <span class="mi">1</span>

<span class="mi">3</span> <span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span> <span class="mi">1</span>

<span class="mi">4</span> <span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">}</span> <span class="mi">3</span>

<span class="mi">5</span> <span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">}</span> <span class="mi">3</span>

<span class="n">A</span> <span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="s1">&#39;Data for A&#39;</span><span class="p">}</span> <span class="kc">None</span>

<span class="n">B</span> <span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="s1">&#39;Data for B&#39;</span><span class="p">}</span> <span class="n">A</span>

<span class="n">C</span> <span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="s1">&#39;Data for C&#39;</span><span class="p">}</span> <span class="n">A</span>

<span class="n">D</span> <span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="s1">&#39;Data for D&#39;</span><span class="p">}</span> <span class="n">C</span>

<span class="n">E</span> <span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="s1">&#39;Data for E&#39;</span><span class="p">}</span> <span class="n">C</span>

<span class="n">F</span> <span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="s1">&#39;Data for F&#39;</span><span class="p">}</span> <span class="n">E</span>

<span class="n">G</span> <span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="s1">&#39;Data for G&#39;</span><span class="p">}</span> <span class="n">E</span>

<span class="n">H</span> <span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="s1">&#39;Data for H&#39;</span><span class="p">}</span> <span class="n">B</span>

<span class="n">I</span> <span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="s1">&#39;Data for I&#39;</span><span class="p">}</span> <span class="n">A</span>

<span class="n">J</span> <span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="s1">&#39;Data for J&#39;</span><span class="p">}</span> <span class="n">I</span>

<span class="n">K</span> <span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="s1">&#39;Data for K&#39;</span><span class="p">}</span> <span class="n">G</span>

<span class="n">L</span> <span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="s1">&#39;Data for L&#39;</span><span class="p">}</span> <span class="n">G</span>

<span class="n">M</span> <span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="s1">&#39;Data for M&#39;</span><span class="p">}</span> <span class="n">C</span>
</pre></div>
</div>
</section>
</section>
<section id="storing-and-transmitting-trees">
<h2>Storing and Transmitting Trees<a class="headerlink" href="#storing-and-transmitting-trees" title="Link to this heading">¶</a></h2>
<p>It’s easy to regenerate any JSON files that may have been used to
generate the <code class="docutils literal notranslate"><span class="pre">FlatForest</span></code> object. So, JSON is a good format for
storing and transmitting trees. And, of course, <code class="docutils literal notranslate"><span class="pre">FlatForest</span></code> <em>is</em> a
dictionary.</p>
<p>Note that when we load a dictionary, the tree is providing a <em>view</em> of it
in-place. So, if we modify the dictionary, we modify the tree, and vice versa.</p>
<section id="creating-a-flatforest-from-a-json">
<h3>Creating a <cite>FlatForest</cite> from a JSON<a class="headerlink" href="#creating-a-flatforest-from-a-json" title="Link to this heading">¶</a></h3>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># load a forest from data
forest2 = FlatForest(deepcopy(data))
# load a forest from a forest
forest3 = FlatForest(forest)

print(forest == forest2)

print(json.dumps(dict(forest), indent=2, sort_keys=True) == json.dumps(dict(forest2), indent=2, sort_keys=True))
print(json.dumps(dict(forest), indent=2, sort_keys=True) == json.dumps(dict(forest3), indent=2, sort_keys=True))
print(json.dumps(dict(forest2), indent=2, sort_keys=True) == json.dumps(dict(forest3), indent=2, sort_keys=True))
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kc">False</span>
<span class="kc">False</span>
<span class="kc">True</span>
<span class="kc">False</span>
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>forest.logical_root_names()
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;__DETACHED__&#39;</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>print(forest.detached)
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FlatForestNode</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">__DETACHED__</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">payload</span><span class="o">=</span><span class="p">{},</span> <span class="n">root</span><span class="o">=</span><span class="n">__DETACHED__</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="p">[])</span>
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>from copy import deepcopy
new_forest = deepcopy(forest)
new_forest.detach(&quot;1&quot;)
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FlatForestNode</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">payload</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="n">root</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;3&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>If we try to detach a node that was already detached, we get a
<code class="docutils literal notranslate"><span class="pre">KeyError</span></code>. Note that this can happen in two ways:</p>
<ol class="arabic simple">
<li><p>The node was detached and then we try to detach it again.</p></li>
<li><p>The node was detached and then we try to detach a child of it.</p></li>
</ol>
<p>Any child of a detached node is also detached, so we can’t detach a
child of a detached node.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>try:
    new_forest.detach(&quot;2&quot;)
except KeyError as e:
    print(f&quot;KeyError: {e}&quot;)
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>forest.as_tree()
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FlatForestNode</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">__ROOT__</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">payload</span><span class="o">=</span><span class="p">{},</span> <span class="n">root</span><span class="o">=</span><span class="n">__ROOT__</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">])</span>
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>forest.preferred_root = &quot;1&quot;
print(pretty_tree(forest.subtree()))
forest.preferred_root = &quot;A&quot;
print(pretty_tree(forest.subtree()))
print(pretty_tree(forest.subtree(&quot;C&quot;)))
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>1
├───── 2
└───── 3
       ├───── 4
       └───── 5

A
├───── B
│      └───── H
├───── C
│      ├───── D
│      ├───── E
│      │      ├───── F
│      │      └───── G
│      │             ├───── K
│      │             └───── L
│      └───── M
└───── I
       └───── J

C
├───── D
├───── E
│      ├───── F
│      └───── G
│             ├───── K
│             └───── L
└───── M
</pre></div>
</div>
<p>For visualizing trees, we can use the <code class="docutils literal notranslate"><span class="pre">PrettyTree</span></code> class and the
<code class="docutils literal notranslate"><span class="pre">pretty_tree</span></code> function. The <code class="docutils literal notranslate"><span class="pre">PrettyTree</span></code> class is a simple tree data
structure that can be used to visualize trees in pretty text format,
optionally with the ability to mark nodes for highlighting.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>monotext(pretty_tree(forest.subtree(&quot;A&quot;), mark=[&quot;A&quot;, &quot;G&quot;], node_details=lambda node: node.payload[&#39;data&#39;]))
</pre></div>
</div>
<pre>A ◄ Data for A 🔵
├───── B ◄ Data for B
│      └───── H ◄ Data for H
├───── C ◄ Data for C
│      ├───── D ◄ Data for D
│      ├───── E ◄ Data for E
│      │      ├───── F ◄ Data for F
│      │      └───── G ◄ Data for G 🟣
│      │             ├───── K ◄ Data for K
│      │             └───── L ◄ Data for L
│      └───── M ◄ Data for M
└───── I ◄ Data for I
       └───── J ◄ Data for J
</pre><div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>monotext(pretty_tree(forest.subtree(&quot;A&quot;), mark=[&quot;H&quot;, &quot;D&quot;]))
</pre></div>
</div>
<pre>A
├───── B
│      └───── H 🟡
├───── C
│      ├───── D ⭕
│      ├───── E
│      │      ├───── F
│      │      └───── G
│      │             ├───── K
│      │             └───── L
│      └───── M
└───── I
       └───── J
</pre><div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>from pprint import pprint
from AlgoTree import utils
pprint(utils.node_stats(forest.subtree(&quot;C&quot;)))
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;node_info&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;ancestors&#39;</span><span class="p">:</span> <span class="p">[],</span>
               <span class="s1">&#39;children&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">],</span>
               <span class="s1">&#39;depth&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
               <span class="s1">&#39;descendants&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="s1">&#39;G&#39;</span><span class="p">,</span> <span class="s1">&#39;K&#39;</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">],</span>
               <span class="s1">&#39;is_internal&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
               <span class="s1">&#39;is_leaf&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
               <span class="s1">&#39;is_root&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
               <span class="s1">&#39;leaves_under&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="s1">&#39;K&#39;</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">],</span>
               <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span>
               <span class="s1">&#39;parent&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
               <span class="s1">&#39;path&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">],</span>
               <span class="s1">&#39;payload&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="s1">&#39;Data for C&#39;</span><span class="p">},</span>
               <span class="s1">&#39;root_distance&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
               <span class="s1">&#39;siblings&#39;</span><span class="p">:</span> <span class="p">[],</span>
               <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s2">&quot;&lt;class &#39;AlgoTree.flat_forest_node.FlatForestNode&#39;&gt;&quot;</span><span class="p">},</span>
 <span class="s1">&#39;subtree_info&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;height&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
                  <span class="s1">&#39;leaves&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="s1">&#39;K&#39;</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">],</span>
                  <span class="s1">&#39;root&#39;</span><span class="p">:</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span>
                  <span class="s1">&#39;size&#39;</span><span class="p">:</span> <span class="mi">8</span><span class="p">}}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">FlatForest</span></code> class provides a <strong>view</strong> of a <code class="docutils literal notranslate"><span class="pre">dict</span></code> object as a
forest. We do not modify the <code class="docutils literal notranslate"><span class="pre">dict</span></code> passed into it (and you can create
a dict through the <code class="docutils literal notranslate"><span class="pre">FlatForest</span></code> API). Since it’s just a view of a
<code class="docutils literal notranslate"><span class="pre">dict</span></code> we have all the normal operations on it that we would have on a
<code class="docutils literal notranslate"><span class="pre">dict</span></code> object.</p>
<p><code class="docutils literal notranslate"><span class="pre">FlatForest</span></code> also implements the concept of a node, which is a view of
a particular node in our node-centric API. In order to do this, we
specify a preferred root node, which by default is the first root node
in the forest. This is the node that will be used as the root node in
the <code class="docutils literal notranslate"><span class="pre">FlatForestNode</span></code> API. If you want to change the root node, you can
do so by calling <code class="docutils literal notranslate"><span class="pre">FlatForest.preferred_root</span></code> with the name of the node
you want to be the preferred root.</p>
<p>We also provide as <code class="docutils literal notranslate"><span class="pre">as_tree</span></code> method that unifies any <code class="docutils literal notranslate"><span class="pre">dict</span></code> object
representing a flat forest structure into a flat forest structure with
just a single root node, where all the root nodes are children of this
root node. This is no longer a view, however, as we return a new
<code class="docutils literal notranslate"><span class="pre">dict</span></code> object.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>print(forest[&quot;C&quot;])
C = forest.subtree(&quot;C&quot;)
print(C)
print(C[&quot;parent&quot;])
print(C.children)
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="s1">&#39;Data for C&#39;</span><span class="p">,</span> <span class="s1">&#39;parent&#39;</span><span class="p">:</span> <span class="s1">&#39;A&#39;</span><span class="p">}</span>
<span class="n">FlatForestNode</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">C</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">payload</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="s1">&#39;Data for C&#39;</span><span class="p">},</span> <span class="n">root</span><span class="o">=</span><span class="n">C</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">])</span>
<span class="n">A</span>
<span class="p">[</span><span class="n">FlatForestNode</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">D</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">C</span><span class="p">,</span> <span class="n">payload</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="s1">&#39;Data for D&#39;</span><span class="p">},</span> <span class="n">root</span><span class="o">=</span><span class="n">C</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="p">[]),</span> <span class="n">FlatForestNode</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">E</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">C</span><span class="p">,</span> <span class="n">payload</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="s1">&#39;Data for E&#39;</span><span class="p">},</span> <span class="n">root</span><span class="o">=</span><span class="n">C</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="s1">&#39;G&#39;</span><span class="p">]),</span> <span class="n">FlatForestNode</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">M</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">C</span><span class="p">,</span> <span class="n">payload</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="s1">&#39;Data for M&#39;</span><span class="p">},</span> <span class="n">root</span><span class="o">=</span><span class="n">C</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="p">[])]</span>
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>N = forest.root.add_child(name=&quot;N&quot;, data=&quot;Data for N&quot;)
print(N)
forest.subtree(&quot;A&quot;).add_child(name=&quot;O&quot;, data=&quot;Data for O&quot;)
monotext(pretty_tree(forest.root.node(&quot;A&quot;), mark=[&quot;O&quot;]))
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FlatForestNode</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">A</span><span class="p">,</span> <span class="n">payload</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="s1">&#39;Data for N&#39;</span><span class="p">},</span> <span class="n">root</span><span class="o">=</span><span class="n">A</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="p">[])</span>
</pre></div>
</div>
<pre>A
├───── B
│      └───── H
├───── C
│      ├───── D
│      ├───── E
│      │      ├───── F
│      │      └───── G
│      │             ├───── K
│      │             └───── L
│      └───── M
├───── I
│      └───── J
├───── N
└───── O 🟡
</pre><p>If we try too add a non-unique node key to the tree, we will get a
<code class="docutils literal notranslate"><span class="pre">KeyError</span></code>.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>try:
    forest.subtree(&quot;A&quot;).add_child(name=&quot;B&quot;)
except KeyError as e:
    print(e)
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s1">&#39;key already exists in the tree: B&#39;</span>
</pre></div>
</div>
<p>Let’s add some more nodes.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>P = N.add_child(name=&quot;P&quot;, data=&quot;Data for P&quot;)
N.add_child(name=&quot;Q&quot;, data=&quot;Data for Q&quot;)
P.add_child(name=&quot;R&quot;, data=&quot;Data for R&quot;).add_child(
    name=&quot;S&quot;, data=&quot;Data for S&quot;
)
monotext(pretty_tree(forest.root, mark=[&quot;N&quot;, &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;]))

print(forest.root.node(&quot;A&quot;))
print(forest.root.node(&quot;A&quot;).parent)
</pre></div>
</div>
<pre>A
├───── B
│      └───── H
├───── C
│      ├───── D
│      ├───── E
│      │      ├───── F
│      │      └───── G
│      │             ├───── K
│      │             └───── L
│      └───── M
├───── I
│      └───── J
├───── N ⭕
│      ├───── P 🟤
│      │      └───── R 🔵
│      │             └───── S 🟤
│      └───── Q 🔘
└───── O
</pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FlatForestNode</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">A</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">payload</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="s1">&#39;Data for A&#39;</span><span class="p">},</span> <span class="n">root</span><span class="o">=</span><span class="n">A</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;I&#39;</span><span class="p">,</span> <span class="s1">&#39;N&#39;</span><span class="p">,</span> <span class="s1">&#39;O&#39;</span><span class="p">])</span>
<span class="kc">None</span>
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>f_nodes = utils.breadth_first_undirected(forest.node(&quot;F&quot;), 2)
print([n.name for n in f_nodes])
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="s1">&#39;G&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>monotext(pretty_tree(utils.subtree_rooted_at(forest.node(&quot;C&quot;), 2), mark=[&quot;C&quot;]))
</pre></div>
</div>
<pre>C ⭕
├───── D
├───── E
│      ├───── F
│      └───── G
└───── M
</pre><div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>center_C = utils.subtree_centered_at(forest.node(&quot;C&quot;), 2)
monotext(pretty_tree(center_C, mark=[&quot;C&quot;]))
monotext(pretty_tree(forest.root, mark=[&quot;C&quot;]))
</pre></div>
</div>
<pre>A
├───── B
├───── C ⭕
│      ├───── D
│      ├───── E
│      │      ├───── F
│      │      └───── G
│      └───── M
├───── I
├───── N
└───── O
</pre><pre>A
├───── B
│      └───── H
├───── C ⭕
│      ├───── D
│      ├───── E
│      │      ├───── F
│      │      └───── G
│      │             ├───── K
│      │             └───── L
│      └───── M
├───── I
│      └───── J
├───── N
│      ├───── P
│      │      └───── R
│      │             └───── S
│      └───── Q
└───── O
</pre><p>We also support conversions to and from any tree-like structure that
supports the node-centric API, including <code class="docutils literal notranslate"><span class="pre">FlatForest</span></code> and a simple
(but far more flexible) <code class="docutils literal notranslate"><span class="pre">TreeNode</span></code> class that we also provide for
illustrative purposes.</p>
<p>The function is called <code class="docutils literal notranslate"><span class="pre">TreeConverter.copy_under</span></code> which accepts a
<code class="docutils literal notranslate"><span class="pre">source</span></code> and <code class="docutils literal notranslate"><span class="pre">target</span></code> object, and copies the <code class="docutils literal notranslate"><span class="pre">source</span></code> object under
the <code class="docutils literal notranslate"><span class="pre">target</span></code> object. The source is normally a node of some kind, and
the target is another node, and the result is the tree structure under
the source node is copied under the target node. The source node is not
modified in any way.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>from AlgoTree.treenode import TreeNode
treeNodeMe = TreeNode(name=&quot;treenode&quot;, payload={&quot;data&quot;: &quot;Data for treenode&quot;})
treeNodeMe.add_child(name=&quot;child1&quot;, payload={&quot;data&quot;: &quot;Data for child1&quot;})
treeNodeMe.add_child(name=&quot;child2&quot;, payload={&quot;data&quot;: &quot;Data for child2&quot;})
tree1 = TreeConverter.copy_under(forest.subtree(&quot;C&quot;), treeNodeMe.children[0])
print(pretty_tree(tree1.root, mark=[&quot;child1&quot;]))
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>treenode
├───── child1 🟡
│      └───── C
│             ├───── D
│             ├───── E
│             │      ├───── F
│             │      └───── G
│             │             ├───── K
│             │             └───── L
│             └───── M
└───── child2
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>tree2 = TreeConverter.copy_under(tree1.root, forest.subtree(&quot;D&quot;), node_name=lambda n: n.name + &quot;_2&quot;)
monotext(pretty_tree(tree2.forest.root))
</pre></div>
</div>
<pre>A
├───── B
│      └───── H
├───── C
│      ├───── D
│      │      └───── treenode_2
│      │             ├───── child1_2
│      │             │      └───── C_2
│      │             │             ├───── D_2
│      │             │             ├───── E_2
│      │             │             │      ├───── F_2
│      │             │             │      └───── G_2
│      │             │             │             ├───── K_2
│      │             │             │             └───── L_2
│      │             │             └───── M_2
│      │             └───── child2_2
│      ├───── E
│      │      ├───── F
│      │      └───── G
│      │             ├───── K
│      │             └───── L
│      └───── M
├───── I
│      └───── J
├───── N
│      ├───── P
│      │      └───── R
│      │             └───── S
│      └───── Q
└───── O
</pre><p>We can iterate over the items of the child and we can modify/delete its
data.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>for k, v in forest.subtree(&quot;N&quot;).items():
    print(k, &quot;&lt;--&quot;, v)

N[&quot;new_data&quot;] = &quot;Some new data for G&quot;
print(N)

del N[&quot;new_data&quot;]
N[&quot;other_new_data&quot;] = &quot;Some other data for G&quot;
print(N)
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">&lt;--</span> <span class="n">Data</span> <span class="k">for</span> <span class="n">N</span>
<span class="n">parent</span> <span class="o">&lt;--</span> <span class="n">A</span>
<span class="n">FlatForestNode</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">A</span><span class="p">,</span> <span class="n">payload</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="s1">&#39;Data for N&#39;</span><span class="p">,</span> <span class="s1">&#39;new_data&#39;</span><span class="p">:</span> <span class="s1">&#39;Some new data for G&#39;</span><span class="p">},</span> <span class="n">root</span><span class="o">=</span><span class="n">A</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="s1">&#39;Q&#39;</span><span class="p">])</span>
<span class="n">FlatForestNode</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">A</span><span class="p">,</span> <span class="n">payload</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="s1">&#39;Data for N&#39;</span><span class="p">,</span> <span class="s1">&#39;other_new_data&#39;</span><span class="p">:</span> <span class="s1">&#39;Some other data for G&#39;</span><span class="p">},</span> <span class="n">root</span><span class="o">=</span><span class="n">A</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="s1">&#39;Q&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>Let’s create a tree from a dictionary that refers to a non-existent
parent.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>try:
    non_existent_parent_tree = FlatForest(
        {
            &quot;A&quot;: {
                &quot;parent&quot;: &quot;non_existent_parent&quot;,
                &quot;data&quot;: &quot;Data for A&quot;,
            }
        }
    )
    FlatForest.check_valid(non_existent_parent_tree)
except KeyError as e:
    print(e)
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;Parent &#39;non_existent_parent&#39; not in forest for node &#39;A&#39;&quot;</span>
</pre></div>
</div>
<p>We see that the node is disconnected from the logical root, since it
refers to a non-existent parent.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>try:
    cycle_tree = FlatForest(
        {
            &quot;x&quot;: {&quot;parent&quot;: None, &quot;data&quot;: &quot;Data for x&quot;},
            &quot;A&quot;: {&quot;parent&quot;: &quot;C&quot;, &quot;data&quot;: &quot;Data for A&quot;},
            &quot;B&quot;: {&quot;parent&quot;: &quot;A&quot;, &quot;data&quot;: &quot;Data for B&quot;},
            &quot;C&quot;: {&quot;parent&quot;: &quot;B&quot;, &quot;data&quot;: &quot;Data for C&quot;},
            &quot;D&quot;: {&quot;parent&quot;: &quot;x&quot;, &quot;data&quot;: &quot;Data for D&quot;},
        }
    )

    monotext(pretty_tree(cycle_tree.root))
    FlatForest.check_valid(cycle_tree)
except ValueError as e:
    print(e)
</pre></div>
</div>
<pre>x
└───── D
</pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Cycle</span> <span class="n">detected</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">}</span>
</pre></div>
</div>
<p>We see that the tree was in an invalid state. In particular, nodes 1, 2,
and 3 are from any root and in a cycle. We can fix this by breaking the
cycle and setting the parent of node 3 to, for instance, to <code class="docutils literal notranslate"><span class="pre">x</span></code>.
However, we can also fix it by setting the parent to <code class="docutils literal notranslate"><span class="pre">None</span></code>, so that
it is a seperate tree in the forest.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>cycle_tree[&quot;C&quot;][&quot;parent&quot;] = None
FlatForest.check_valid(cycle_tree)
monotext(pretty_tree(cycle_tree.subtree(&quot;C&quot;), mark=[&quot;C&quot;]))
print(cycle_tree.root_names)
</pre></div>
</div>
<pre>C ⭕
└───── A
       └───── B
</pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;__DETACHED__&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>Let’s look at the tree again, and see about creating a cycle.</p>
<p>We will make node 1 the parent of node 5, to create a cycle:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>try:
    new_tree = deepcopy(forest.root)
    new_tree.node(&quot;A&quot;)[&quot;parent&quot;] = &quot;E&quot;
    FlatForest.check_valid(new_tree)
except ValueError as e:
    print(e)
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">a</span> <span class="n">dictionary</span><span class="p">:</span> <span class="n">data</span><span class="o">=</span><span class="n">FlatForestNode</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">A</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">payload</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="s1">&#39;Data for A&#39;</span><span class="p">},</span> <span class="n">root</span><span class="o">=</span><span class="n">A</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;I&#39;</span><span class="p">,</span> <span class="s1">&#39;N&#39;</span><span class="p">,</span> <span class="s1">&#39;O&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>Notice that we use <code class="docutils literal notranslate"><span class="pre">deepcopy</span></code> to avoid modifying the original tree
with these invalid operations. We chose to do it this way so as to not
incur the overhead of reverting the tree to a valid state after an
invalid operation. This way, we can keep the tree in an invalid state
for as long as we want, and only revert it to a valid state when we want
to.</p>
<p>Each node is a key-value pair in the <code class="docutils literal notranslate"><span class="pre">FlatForest</span></code>. We have the
<code class="docutils literal notranslate"><span class="pre">FlatForestNode</span></code> so that we can have an API focused on the nodes and
not the underlying dictionary. However, we stiill permit access to the
underlying dictionary. When you modify the tree in this way, we still
maintain the integrity of the tree.</p>
<p>Since the <code class="docutils literal notranslate"><span class="pre">FlatForest</span></code> represents nodes as key-value pairs, and the
value may have a parent key, along with any other arbitrary data, each
value for a node must be a dictionary.</p>
<p>Below, we see that trying to add a <code class="docutils literal notranslate"><span class="pre">test</span></code> node with a non-dictionary
value generates an error.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>try:
    error_tree = deepcopy(forest)
    # this will raise a ValueError because the node with key `test` maps to
    # string instead of a dict.
    error_tree[&quot;test&quot;] = &quot;Some test data&quot;
    FlatForest.check_valid(error_tree)
except ValueError as e:
    print(e)
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Node</span> <span class="s1">&#39;test&#39;</span> <span class="n">does</span> <span class="ow">not</span> <span class="n">have</span> <span class="n">a</span> <span class="n">payload</span> <span class="n">dictionary</span><span class="p">:</span> <span class="s1">&#39;Some test data&#39;</span>
</pre></div>
</div>
<p>Let’s manipulate the tree a bit more using the <code class="docutils literal notranslate"><span class="pre">dict</span></code> API. We’re just
going to add a <code class="docutils literal notranslate"><span class="pre">new_node</span></code> with some data.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>forest[&quot;T&quot;] = {
    &quot;parent&quot;: &quot;B&quot;,
    &quot;data&quot;: &quot;Data for T&quot;
}

print(forest.node(&quot;T&quot;))
print(pretty_tree(forest.subtree(&quot;B&quot;), mark=[&quot;T&quot;]))
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>FlatForestNode(name=T, parent=B, payload={&#39;data&#39;: &#39;Data for T&#39;}, root=A, children=[])
B
├───── H
└───── T 🔵
</pre></div>
</div>
<p>Logical roots are not a part of the underlying dictionary, so we can’t
access it through the <code class="docutils literal notranslate"><span class="pre">dict</span></code> API. It’s non-children data are also
immutable through the <code class="docutils literal notranslate"><span class="pre">FlatForestNode</span></code> API. Right now, we use
<code class="docutils literal notranslate"><span class="pre">FlatForest.DETACHED_KEY</span></code> as a logical root for detached nodes.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>print(forest.detached)
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FlatForestNode</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">__DETACHED__</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">payload</span><span class="o">=</span><span class="p">{},</span> <span class="n">root</span><span class="o">=</span><span class="n">__DETACHED__</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="p">[])</span>
</pre></div>
</div>
<p>We see that there are no detached nodes in the forest right now.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>try:
    forest.detached[&quot;data&quot;] = &quot;Some new data for root node&quot;
except TypeError as e:
    print(e)

try:
    forest.detached[&quot;parent&quot;] = None
except TypeError as e:
    print(e)
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">__DETACHED__</span> <span class="ow">is</span> <span class="n">an</span> <span class="n">immutable</span> <span class="n">logical</span> <span class="n">root</span>
<span class="n">__DETACHED__</span> <span class="ow">is</span> <span class="n">an</span> <span class="n">immutable</span> <span class="n">logical</span> <span class="n">root</span>
</pre></div>
</div>
<p>We can <em>detach</em> nodes. Let’s first view the full tree, pre-detachment.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>monotext(pretty_tree(forest.root))
</pre></div>
</div>
<pre>A
├───── B
│      ├───── H
│      └───── T
├───── C
│      ├───── D
│      │      └───── treenode_2
│      │             ├───── child1_2
│      │             │      └───── C_2
│      │             │             ├───── D_2
│      │             │             ├───── E_2
│      │             │             │      ├───── F_2
│      │             │             │      └───── G_2
│      │             │             │             ├───── K_2
│      │             │             │             └───── L_2
│      │             │             └───── M_2
│      │             └───── child2_2
│      ├───── E
│      │      ├───── F
│      │      └───── G
│      │             ├───── K
│      │             └───── L
│      └───── M
├───── I
│      └───── J
├───── N
│      ├───── P
│      │      └───── R
│      │             └───── S
│      └───── Q
└───── O
</pre><div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>forest.node(&quot;D&quot;).detach()
forest.detach(&quot;G&quot;)
monotext(pretty_tree(forest.root))
</pre></div>
</div>
<pre>A
├───── B
│      ├───── H
│      └───── T
├───── C
│      ├───── E
│      │      └───── F
│      └───── M
├───── I
│      └───── J
├───── N
│      ├───── P
│      │      └───── R
│      │             └───── S
│      └───── Q
└───── O
</pre><p>Let’s view the detached tree.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>monotext(pretty_tree(forest.detached, mark=[&quot;B&quot;, &quot;C&quot;]))
</pre></div>
</div>
<pre>__DETACHED__
├───── D
│      └───── treenode_2
│             ├───── child1_2
│             │      └───── C_2
│             │             ├───── D_2
│             │             ├───── E_2
│             │             │      ├───── F_2
│             │             │      └───── G_2
│             │             │             ├───── K_2
│             │             │             └───── L_2
│             │             └───── M_2
│             └───── child2_2
└───── G
       ├───── K
       └───── L
</pre><p>We can purge detached nodes (and their descendants) from the tree with
the <code class="docutils literal notranslate"><span class="pre">purge</span></code> method. Let’s purge the detached nodes. Note that when we
do this, through the node-centric API, nothing will seem different
(unless we look at the tree rooted at the detached logical root).
However, if we look at the underlying dictionary, we will see that the
detached nodes are gone.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>forest.purge()
print(json.dumps(forest, indent=2))
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="s2">&quot;1&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="s2">&quot;parent&quot;</span><span class="p">:</span> <span class="n">null</span>
  <span class="p">},</span>
  <span class="s2">&quot;2&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
    <span class="s2">&quot;parent&quot;</span><span class="p">:</span> <span class="s2">&quot;1&quot;</span>
  <span class="p">},</span>
  <span class="s2">&quot;3&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
    <span class="s2">&quot;parent&quot;</span><span class="p">:</span> <span class="s2">&quot;1&quot;</span>
  <span class="p">},</span>
  <span class="s2">&quot;4&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
    <span class="s2">&quot;parent&quot;</span><span class="p">:</span> <span class="s2">&quot;3&quot;</span>
  <span class="p">},</span>
  <span class="s2">&quot;5&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
    <span class="s2">&quot;parent&quot;</span><span class="p">:</span> <span class="s2">&quot;3&quot;</span>
  <span class="p">},</span>
  <span class="s2">&quot;A&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="s2">&quot;Data for A&quot;</span><span class="p">,</span>
    <span class="s2">&quot;parent&quot;</span><span class="p">:</span> <span class="n">null</span>
  <span class="p">},</span>
  <span class="s2">&quot;B&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="s2">&quot;Data for B&quot;</span><span class="p">,</span>
    <span class="s2">&quot;parent&quot;</span><span class="p">:</span> <span class="s2">&quot;A&quot;</span>
  <span class="p">},</span>
  <span class="s2">&quot;C&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="s2">&quot;Data for C&quot;</span><span class="p">,</span>
    <span class="s2">&quot;parent&quot;</span><span class="p">:</span> <span class="s2">&quot;A&quot;</span>
  <span class="p">},</span>
  <span class="s2">&quot;E&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="s2">&quot;Data for E&quot;</span><span class="p">,</span>
    <span class="s2">&quot;parent&quot;</span><span class="p">:</span> <span class="s2">&quot;C&quot;</span>
  <span class="p">},</span>
  <span class="s2">&quot;F&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="s2">&quot;Data for F&quot;</span><span class="p">,</span>
    <span class="s2">&quot;parent&quot;</span><span class="p">:</span> <span class="s2">&quot;E&quot;</span>
  <span class="p">},</span>
  <span class="s2">&quot;H&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="s2">&quot;Data for H&quot;</span><span class="p">,</span>
    <span class="s2">&quot;parent&quot;</span><span class="p">:</span> <span class="s2">&quot;B&quot;</span>
  <span class="p">},</span>
  <span class="s2">&quot;I&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="s2">&quot;Data for I&quot;</span><span class="p">,</span>
    <span class="s2">&quot;parent&quot;</span><span class="p">:</span> <span class="s2">&quot;A&quot;</span>
  <span class="p">},</span>
  <span class="s2">&quot;J&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="s2">&quot;Data for J&quot;</span><span class="p">,</span>
    <span class="s2">&quot;parent&quot;</span><span class="p">:</span> <span class="s2">&quot;I&quot;</span>
  <span class="p">},</span>
  <span class="s2">&quot;M&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="s2">&quot;Data for M&quot;</span><span class="p">,</span>
    <span class="s2">&quot;parent&quot;</span><span class="p">:</span> <span class="s2">&quot;C&quot;</span>
  <span class="p">},</span>
  <span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="s2">&quot;Data for N&quot;</span><span class="p">,</span>
    <span class="s2">&quot;parent&quot;</span><span class="p">:</span> <span class="s2">&quot;A&quot;</span><span class="p">,</span>
    <span class="s2">&quot;other_new_data&quot;</span><span class="p">:</span> <span class="s2">&quot;Some other data for G&quot;</span>
  <span class="p">},</span>
  <span class="s2">&quot;O&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="s2">&quot;Data for O&quot;</span><span class="p">,</span>
    <span class="s2">&quot;parent&quot;</span><span class="p">:</span> <span class="s2">&quot;A&quot;</span>
  <span class="p">},</span>
  <span class="s2">&quot;P&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="s2">&quot;Data for P&quot;</span><span class="p">,</span>
    <span class="s2">&quot;parent&quot;</span><span class="p">:</span> <span class="s2">&quot;N&quot;</span>
  <span class="p">},</span>
  <span class="s2">&quot;Q&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="s2">&quot;Data for Q&quot;</span><span class="p">,</span>
    <span class="s2">&quot;parent&quot;</span><span class="p">:</span> <span class="s2">&quot;N&quot;</span>
  <span class="p">},</span>
  <span class="s2">&quot;R&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="s2">&quot;Data for R&quot;</span><span class="p">,</span>
    <span class="s2">&quot;parent&quot;</span><span class="p">:</span> <span class="s2">&quot;P&quot;</span>
  <span class="p">},</span>
  <span class="s2">&quot;S&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="s2">&quot;Data for S&quot;</span><span class="p">,</span>
    <span class="s2">&quot;parent&quot;</span><span class="p">:</span> <span class="s2">&quot;R&quot;</span>
  <span class="p">},</span>
  <span class="s2">&quot;T&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="s2">&quot;parent&quot;</span><span class="p">:</span> <span class="s2">&quot;B&quot;</span><span class="p">,</span>
    <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="s2">&quot;Data for T&quot;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We have a fairly complete API for manipulating the forest. Let’s explore
some additional methods. Let’s first create a node itrator to node A,
and then access or modify the payload data for node A. Since payload
data is mutable, and it must be a dictionary, we can access or modify it
using the dict API.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>forest.node(&quot;A&quot;).clear()
forest.node(&quot;A&quot;)[&quot;new_data&quot;] = &quot;Some new data for A&quot;
forest.node(&quot;A&quot;)[&quot;other_new_data&quot;] = &quot;Some other data for A&quot;
print(forest[&quot;A&quot;])
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;new_data&#39;</span><span class="p">:</span> <span class="s1">&#39;Some new data for A&#39;</span><span class="p">,</span> <span class="s1">&#39;other_new_data&#39;</span><span class="p">:</span> <span class="s1">&#39;Some other data for A&#39;</span><span class="p">}</span>
</pre></div>
</div>
<p>This is fairly self-expalanatory.</p>
<p>Let’s add some more nodes without specifying a key name for them, since
often we don’t care about the key name and it’s only for bookkeeping
purposes.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>forest.root.add_child(whatever=3).add_child(
    name=&quot;U&quot;, whatever=4).add_child(whatever=5)
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FlatForestNode</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="mi">779</span><span class="n">cc759</span><span class="o">-</span><span class="mi">36</span><span class="n">a9</span><span class="o">-</span><span class="mi">4</span><span class="n">dae</span><span class="o">-</span><span class="n">a1c9</span><span class="o">-</span><span class="n">e021d65aa1d4</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">U</span><span class="p">,</span> <span class="n">payload</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;whatever&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">},</span> <span class="n">root</span><span class="o">=</span><span class="n">A</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="p">[])</span>
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>FlatForestNode(whatever=1000, parent=forest.root.children[0])
FlatForestNode(name=&quot;V&quot;, whatever=2000, parent=forest.root.children[0].children[1])
FlatForestNode(whatever=3000, more_data=&quot;yes&quot;, parent=forest.node(&quot;V&quot;))
FlatForestNode(name=&quot;W&quot;, parent=forest.root, whatever=200)
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FlatForestNode</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">W</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">A</span><span class="p">,</span> <span class="n">payload</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;whatever&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">},</span> <span class="n">root</span><span class="o">=</span><span class="n">A</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="p">[])</span>
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>forest.node(&quot;V&quot;).parent = forest.node(&quot;W&quot;)
monotext(pretty_tree(forest.root, mark=[&quot;U&quot;, &quot;V&quot;, &quot;W&quot;], node_details=lambda n: n.payload))
</pre></div>
</div>
<pre>A ◄ {'new_data': 'Some new data for A', 'other_new_data': 'Some other data for A'}
├───── B ◄ {'data': 'Data for B'}
│      ├───── H ◄ {'data': 'Data for H'}
│      ├───── T ◄ {'data': 'Data for T'}
│      └───── d433395a-27bc-457d-b6d9-c7034d020978 ◄ {'whatever': 1000}
├───── C ◄ {'data': 'Data for C'}
│      ├───── E ◄ {'data': 'Data for E'}
│      │      └───── F ◄ {'data': 'Data for F'}
│      └───── M ◄ {'data': 'Data for M'}
├───── I ◄ {'data': 'Data for I'}
│      └───── J ◄ {'data': 'Data for J'}
├───── N ◄ {'data': 'Data for N', 'other_new_data': 'Some other data for G'}
│      ├───── P ◄ {'data': 'Data for P'}
│      │      └───── R ◄ {'data': 'Data for R'}
│      │             └───── S ◄ {'data': 'Data for S'}
│      └───── Q ◄ {'data': 'Data for Q'}
├───── O ◄ {'data': 'Data for O'}
├───── 945ef525-fece-45f0-a499-b5449d28ef1e ◄ {'whatever': 3}
│      └───── U ◄ {'whatever': 4} 🔴
│             └───── 779cc759-36a9-4dae-a1c9-e021d65aa1d4 ◄ {'whatever': 5}
└───── W ◄ {'whatever': 200} ⚫
       └───── V ◄ {'whatever': 2000} 🔘
              └───── 14e057df-8004-47c3-9415-b7c7235ea4d8 ◄ {'whatever': 3000, 'more_data': 'yes'}
</pre><p>Let’s look at some tree conversions. We can convert between different
tree representations and data structures.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>new_tree = TreeConverter.convert(forest.root, TreeNode)
monotext(pretty_tree(new_tree, node_details=lambda n: n.payload))
</pre></div>
</div>
<pre>A ◄ {'new_data': 'Some new data for A', 'other_new_data': 'Some other data for A'}
├───── B ◄ None
│      ├───── H ◄ None
│      ├───── T ◄ None
│      └───── d433395a-27bc-457d-b6d9-c7034d020978 ◄ None
├───── C ◄ None
│      ├───── E ◄ None
│      │      └───── F ◄ None
│      └───── M ◄ None
├───── I ◄ None
│      └───── J ◄ None
├───── N ◄ None
│      ├───── P ◄ None
│      │      └───── R ◄ None
│      │             └───── S ◄ None
│      └───── Q ◄ None
├───── O ◄ None
├───── 945ef525-fece-45f0-a499-b5449d28ef1e ◄ None
│      └───── U ◄ None
│             └───── 779cc759-36a9-4dae-a1c9-e021d65aa1d4 ◄ None
└───── W ◄ None
       └───── V ◄ None
              └───── 14e057df-8004-47c3-9415-b7c7235ea4d8 ◄ None
</pre><p>We see that it’s a different type of tree, a <code class="docutils literal notranslate"><span class="pre">TreeNode</span></code>, which is a
recursive data structure. It models the same tree data, but in a
different way. This one is also more flexible, so that it doesn’t
require unique names or the payload data to be a dictionary - it can be
any object or value. This simplicity comes at the cost of not being a
dictionary (or view of a dictionary), as FlatForest does.</p>
<p>We see that it has a very different structure. However, when we
pretty-print it using <code class="docutils literal notranslate"><span class="pre">TreeViz</span></code>, we see that it’s the same tree.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>monotext(pretty_tree(forest.root))
monotext(pretty_tree(new_tree))
</pre></div>
</div>
<pre>A
├───── B
│      ├───── H
│      ├───── T
│      └───── d433395a-27bc-457d-b6d9-c7034d020978
├───── C
│      ├───── E
│      │      └───── F
│      └───── M
├───── I
│      └───── J
├───── N
│      ├───── P
│      │      └───── R
│      │             └───── S
│      └───── Q
├───── O
├───── 945ef525-fece-45f0-a499-b5449d28ef1e
│      └───── U
│             └───── 779cc759-36a9-4dae-a1c9-e021d65aa1d4
└───── W
       └───── V
              └───── 14e057df-8004-47c3-9415-b7c7235ea4d8
</pre><pre>A
├───── B
│      ├───── H
│      ├───── T
│      └───── d433395a-27bc-457d-b6d9-c7034d020978
├───── C
│      ├───── E
│      │      └───── F
│      └───── M
├───── I
│      └───── J
├───── N
│      ├───── P
│      │      └───── R
│      │             └───── S
│      └───── Q
├───── O
├───── 945ef525-fece-45f0-a499-b5449d28ef1e
│      └───── U
│             └───── 779cc759-36a9-4dae-a1c9-e021d65aa1d4
└───── W
       └───── V
              └───── 14e057df-8004-47c3-9415-b7c7235ea4d8
</pre><div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>result = TreeConverter.copy_under(new_tree, FlatForestNode(name=&quot;new_root&quot;))
monotext(pretty_tree(result))
result2 = TreeConverter.copy_under(result, new_tree)
monotext(pretty_tree(result2))
</pre></div>
</div>
<pre>A
├───── B
│      ├───── H
│      ├───── T
│      └───── d433395a-27bc-457d-b6d9-c7034d020978
├───── C
│      ├───── E
│      │      └───── F
│      └───── M
├───── I
│      └───── J
├───── N
│      ├───── P
│      │      └───── R
│      │             └───── S
│      └───── Q
├───── O
├───── 945ef525-fece-45f0-a499-b5449d28ef1e
│      └───── U
│             └───── 779cc759-36a9-4dae-a1c9-e021d65aa1d4
└───── W
       └───── V
              └───── 14e057df-8004-47c3-9415-b7c7235ea4d8
</pre><pre>A
├───── B
│      ├───── H
│      ├───── T
│      └───── d433395a-27bc-457d-b6d9-c7034d020978
├───── C
│      ├───── E
│      │      └───── F
│      └───── M
├───── I
│      └───── J
├───── N
│      ├───── P
│      │      └───── R
│      │             └───── S
│      └───── Q
├───── O
├───── 945ef525-fece-45f0-a499-b5449d28ef1e
│      └───── U
│             └───── 779cc759-36a9-4dae-a1c9-e021d65aa1d4
└───── W
       └───── V
              └───── 14e057df-8004-47c3-9415-b7c7235ea4d8
</pre><p>The <code class="docutils literal notranslate"><span class="pre">TreeNode</span></code> is a bit more useful for operations that require
recursion, but any tree can support the sae operations. The <code class="docutils literal notranslate"><span class="pre">TreeNode</span></code>
is a bit more specialized for this purpose, and the <code class="docutils literal notranslate"><span class="pre">FlatTree</span></code> is a
bit more specialized for more general storage and manipulation of data
that is tree-like, such as configuration data or log data. See
<code class="docutils literal notranslate"><span class="pre">TreeNode.md</span></code> for more information on the <code class="docutils literal notranslate"><span class="pre">TreeNode</span></code> class.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>root = TreeNode(name=&quot;root&quot;, payload= {&quot;value&quot;:0}, parent=None)
A = TreeNode(name=&quot;A&quot;, payload={&quot;value&quot;:1}, parent=root)
print(root.children)
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">TreeNode</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">A</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">root</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="n">root</span><span class="p">,</span> <span class="n">payload</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="nb">len</span><span class="p">(</span><span class="n">children</span><span class="p">)</span><span class="o">=</span><span class="mi">0</span><span class="p">)]</span>
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>root2 = TreeNode(name=&quot;root&quot;, payload=0)
A2 = TreeNode(name=&quot;A&quot;, parent=root2, payload=1)
B2 = TreeNode(name=&quot;B&quot;, parent=root2, payload=2)
C2 = TreeNode(name=&quot;C&quot;, parent=root2, payload=3)
D2 = TreeNode(name=&quot;D&quot;, parent=C2, payload=4)
E2 = TreeNode(name=&quot;E&quot;, parent=C2, payload=5)
F2 = TreeNode(name=&quot;F&quot;, parent=C2, payload=&quot;test&quot;)
G2 = TreeNode(name=&quot;G&quot;, parent=C2, payload=7)
H2 = TreeNode(name=&quot;H&quot;, parent=C2, payload=({1: 2}, [3, 4]))
I2 = TreeNode(name=&quot;I&quot;, parent=F2, payload=9)
monotext(pretty_tree(root2, node_details=lambda n: n.payload))
</pre></div>
</div>
<pre>root ◄ 0
├───── A ◄ 1
├───── B ◄ 2
└───── C ◄ 3
       ├───── D ◄ 4
       ├───── E ◄ 5
       ├───── F ◄ test
       │      └───── I ◄ 9
       ├───── G ◄ 7
       └───── H ◄ ({1: 2}, [3, 4])
</pre></section>
</section>
<section id="algorithm-examples">
<h2>Algorithm Examples<a class="headerlink" href="#algorithm-examples" title="Link to this heading">¶</a></h2>
<p>Using utility algorithms with <code class="docutils literal notranslate"><span class="pre">FlatTree</span></code> and <code class="docutils literal notranslate"><span class="pre">FlatTreeNode</span></code>:</p>
<p>Finding descendants of a node:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>from AlgoTree.utils import *
from pprint import pprint
pprint(descendants(C))
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">FlatForestNode</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">E</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">C</span><span class="p">,</span> <span class="n">payload</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="s1">&#39;Data for E&#39;</span><span class="p">},</span> <span class="n">root</span><span class="o">=</span><span class="n">C</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">]),</span>
 <span class="n">FlatForestNode</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">F</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">E</span><span class="p">,</span> <span class="n">payload</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="s1">&#39;Data for F&#39;</span><span class="p">},</span> <span class="n">root</span><span class="o">=</span><span class="n">C</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="p">[]),</span>
 <span class="n">FlatForestNode</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">M</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">C</span><span class="p">,</span> <span class="n">payload</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="s1">&#39;Data for M&#39;</span><span class="p">},</span> <span class="n">root</span><span class="o">=</span><span class="n">C</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="p">[])]</span>
</pre></div>
</div>
<p>Finding ancestors of a node:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>pprint(ancestors(I2))
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">TreeNode</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">F</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">C</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="n">root</span><span class="p">,</span> <span class="n">payload</span><span class="o">=</span><span class="n">test</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">children</span><span class="p">)</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
 <span class="n">TreeNode</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">C</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">root</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="n">root</span><span class="p">,</span> <span class="n">payload</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">children</span><span class="p">)</span><span class="o">=</span><span class="mi">5</span><span class="p">),</span>
 <span class="n">TreeNode</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">root</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="n">root</span><span class="p">,</span> <span class="n">payload</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">children</span><span class="p">)</span><span class="o">=</span><span class="mi">3</span><span class="p">)]</span>
</pre></div>
</div>
<p>Finding siblings of a node:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>pprint(siblings(E2))
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[]</span>
</pre></div>
</div>
<p>Finding leaves of a node:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>pprint(leaves(root2))
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">TreeNode</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">A</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">root</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="n">root</span><span class="p">,</span> <span class="n">payload</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">children</span><span class="p">)</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
 <span class="n">TreeNode</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">B</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">root</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="n">root</span><span class="p">,</span> <span class="n">payload</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">children</span><span class="p">)</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
 <span class="n">TreeNode</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">D</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">C</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="n">root</span><span class="p">,</span> <span class="n">payload</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">children</span><span class="p">)</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
 <span class="n">TreeNode</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">E</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">C</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="n">root</span><span class="p">,</span> <span class="n">payload</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">children</span><span class="p">)</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
 <span class="n">TreeNode</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">I</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">F</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="n">root</span><span class="p">,</span> <span class="n">payload</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">children</span><span class="p">)</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
 <span class="n">TreeNode</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">G</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">C</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="n">root</span><span class="p">,</span> <span class="n">payload</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">children</span><span class="p">)</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
 <span class="n">TreeNode</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">C</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="n">root</span><span class="p">,</span> <span class="n">payload</span><span class="o">=</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]),</span> <span class="nb">len</span><span class="p">(</span><span class="n">children</span><span class="p">)</span><span class="o">=</span><span class="mi">0</span><span class="p">)]</span>
</pre></div>
</div>
<p>Finding the height of a tree:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>pprint(height(root2))
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">3</span>
</pre></div>
</div>
<p>Finding the depth of a node:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>pprint(depth(F2))
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">2</span>
</pre></div>
</div>
<p>Breadth-first traversal:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>def print_node(node, level):
    print(f&quot;Level {level}: {node.name}&quot;)
    return False

breadth_first(root2, print_node)
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Level</span> <span class="mi">0</span><span class="p">:</span> <span class="n">root</span>
<span class="n">Level</span> <span class="mi">1</span><span class="p">:</span> <span class="n">A</span>
<span class="n">Level</span> <span class="mi">1</span><span class="p">:</span> <span class="n">B</span>
<span class="n">Level</span> <span class="mi">1</span><span class="p">:</span> <span class="n">C</span>
<span class="n">Level</span> <span class="mi">2</span><span class="p">:</span> <span class="n">D</span>
<span class="n">Level</span> <span class="mi">2</span><span class="p">:</span> <span class="n">E</span>
<span class="n">Level</span> <span class="mi">2</span><span class="p">:</span> <span class="n">F</span>
<span class="n">Level</span> <span class="mi">2</span><span class="p">:</span> <span class="n">G</span>
<span class="n">Level</span> <span class="mi">2</span><span class="p">:</span> <span class="n">H</span>
<span class="n">Level</span> <span class="mi">3</span><span class="p">:</span> <span class="n">I</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kc">False</span>
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>print(json.dumps(utils.node_stats(forest.node(&quot;N&quot;)), indent=2))
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="s2">&quot;node_info&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;&lt;class &#39;AlgoTree.flat_forest_node.FlatForestNode&#39;&gt;&quot;</span><span class="p">,</span>
    <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;N&quot;</span><span class="p">,</span>
    <span class="s2">&quot;payload&quot;</span><span class="p">:</span> <span class="p">{</span>
      <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="s2">&quot;Data for N&quot;</span><span class="p">,</span>
      <span class="s2">&quot;other_new_data&quot;</span><span class="p">:</span> <span class="s2">&quot;Some other data for G&quot;</span>
    <span class="p">},</span>
    <span class="s2">&quot;children&quot;</span><span class="p">:</span> <span class="p">[</span>
      <span class="s2">&quot;P&quot;</span><span class="p">,</span>
      <span class="s2">&quot;Q&quot;</span>
    <span class="p">],</span>
    <span class="s2">&quot;parent&quot;</span><span class="p">:</span> <span class="s2">&quot;A&quot;</span><span class="p">,</span>
    <span class="s2">&quot;depth&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="s2">&quot;is_root&quot;</span><span class="p">:</span> <span class="n">false</span><span class="p">,</span>
    <span class="s2">&quot;is_leaf&quot;</span><span class="p">:</span> <span class="n">false</span><span class="p">,</span>
    <span class="s2">&quot;is_internal&quot;</span><span class="p">:</span> <span class="n">true</span><span class="p">,</span>
    <span class="s2">&quot;ancestors&quot;</span><span class="p">:</span> <span class="p">[</span>
      <span class="s2">&quot;A&quot;</span>
    <span class="p">],</span>
    <span class="s2">&quot;siblings&quot;</span><span class="p">:</span> <span class="p">[</span>
      <span class="s2">&quot;B&quot;</span><span class="p">,</span>
      <span class="s2">&quot;C&quot;</span><span class="p">,</span>
      <span class="s2">&quot;I&quot;</span><span class="p">,</span>
      <span class="s2">&quot;O&quot;</span><span class="p">,</span>
      <span class="s2">&quot;945ef525-fece-45f0-a499-b5449d28ef1e&quot;</span><span class="p">,</span>
      <span class="s2">&quot;W&quot;</span>
    <span class="p">],</span>
    <span class="s2">&quot;descendants&quot;</span><span class="p">:</span> <span class="p">[</span>
      <span class="s2">&quot;P&quot;</span><span class="p">,</span>
      <span class="s2">&quot;R&quot;</span><span class="p">,</span>
      <span class="s2">&quot;S&quot;</span><span class="p">,</span>
      <span class="s2">&quot;Q&quot;</span>
    <span class="p">],</span>
    <span class="s2">&quot;path&quot;</span><span class="p">:</span> <span class="p">[</span>
      <span class="s2">&quot;A&quot;</span><span class="p">,</span>
      <span class="s2">&quot;N&quot;</span>
    <span class="p">],</span>
    <span class="s2">&quot;root_distance&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="s2">&quot;leaves_under&quot;</span><span class="p">:</span> <span class="p">[</span>
      <span class="s2">&quot;S&quot;</span><span class="p">,</span>
      <span class="s2">&quot;Q&quot;</span>
    <span class="p">]</span>
  <span class="p">},</span>
  <span class="s2">&quot;subtree_info&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="s2">&quot;leaves&quot;</span><span class="p">:</span> <span class="p">[</span>
      <span class="s2">&quot;H&quot;</span><span class="p">,</span>
      <span class="s2">&quot;T&quot;</span><span class="p">,</span>
      <span class="s2">&quot;d433395a-27bc-457d-b6d9-c7034d020978&quot;</span><span class="p">,</span>
      <span class="s2">&quot;F&quot;</span><span class="p">,</span>
      <span class="s2">&quot;M&quot;</span><span class="p">,</span>
      <span class="s2">&quot;J&quot;</span><span class="p">,</span>
      <span class="s2">&quot;S&quot;</span><span class="p">,</span>
      <span class="s2">&quot;Q&quot;</span><span class="p">,</span>
      <span class="s2">&quot;O&quot;</span><span class="p">,</span>
      <span class="s2">&quot;779cc759-36a9-4dae-a1c9-e021d65aa1d4&quot;</span><span class="p">,</span>
      <span class="s2">&quot;14e057df-8004-47c3-9415-b7c7235ea4d8&quot;</span>
    <span class="p">],</span>
    <span class="s2">&quot;height&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
    <span class="s2">&quot;root&quot;</span><span class="p">:</span> <span class="s2">&quot;A&quot;</span><span class="p">,</span>
    <span class="s2">&quot;size&quot;</span><span class="p">:</span> <span class="mi">5</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Mapping a function over the nodes:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>def add_prefix(node):
    if node is None:
        return None
    elif node.name == &quot;D&quot;:
        # add Q and R as children of D
        node.add_child(name=&quot;Q&quot;, value=41)
        node.add_child(name=&quot;R&quot;, value=42)
    elif node.name == &quot;I&quot; or node.name == &quot;W&quot;:
        # delete I by returning None (i.e. don&#39;t add it to the new tree)
        return None
    elif &quot;U&quot; in [child.name for child in node.children]:
        return None
    return node

root_mapped = map(deepcopy(forest.root), add_prefix)

monotext(pretty_tree(root_mapped))

monotext(pretty_tree(forest.root))
</pre></div>
</div>
<pre>A
├───── B
│      ├───── H
│      ├───── T
│      └───── d433395a-27bc-457d-b6d9-c7034d020978
├───── C
│      ├───── E
│      │      └───── F
│      └───── M
├───── N
│      ├───── P
│      │      └───── R
│      │             └───── S
│      └───── Q
└───── O
</pre><pre>A
├───── B
│      ├───── H
│      ├───── T
│      └───── d433395a-27bc-457d-b6d9-c7034d020978
├───── C
│      ├───── E
│      │      └───── F
│      └───── M
├───── I
│      └───── J
├───── N
│      ├───── P
│      │      └───── R
│      │             └───── S
│      └───── Q
├───── O
├───── 945ef525-fece-45f0-a499-b5449d28ef1e
│      └───── U
│             └───── 779cc759-36a9-4dae-a1c9-e021d65aa1d4
└───── W
       └───── V
              └───── 14e057df-8004-47c3-9415-b7c7235ea4d8
</pre><p>Pruning nodes based on a predicate:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>def should_prune(node):
    return node.name == &quot;A&quot;

monotext(pretty_tree(root2))
pruned_tree = prune(root2, should_prune)
monotext(pretty_tree(pruned_tree))
</pre></div>
</div>
<pre>root
├───── A
├───── B
└───── C
       ├───── D
       ├───── E
       ├───── F
       │      └───── I
       ├───── G
       └───── H
</pre><pre>root
├───── B
└───── C
       ├───── D
       ├───── E
       ├───── F
       │      └───── I
       ├───── G
       └───── H
</pre><p>Finding root-to-leaf paths:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>from pprint import pprint
paths = node_to_leaf_paths(root)
# print max path length from root to leaf
pprint(max(paths, key=len))
print(utils.height(root) == len(max(paths, key=len)) - 1)
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">TreeNode</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">root</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="n">root</span><span class="p">,</span> <span class="n">payload</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">},</span> <span class="nb">len</span><span class="p">(</span><span class="n">children</span><span class="p">)</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
 <span class="n">TreeNode</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">A</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">root</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="n">root</span><span class="p">,</span> <span class="n">payload</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="nb">len</span><span class="p">(</span><span class="n">children</span><span class="p">)</span><span class="o">=</span><span class="mi">0</span><span class="p">)]</span>
<span class="kc">True</span>
</pre></div>
</div>
<p>Converting paths to a tree:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>rooter = paths_to_tree([[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], [&quot;a&quot;, &quot;b&quot;, &quot;d&quot;], [&quot;a&quot;, &quot;e&quot;, &quot;d&quot;],
                        [&quot;a&quot;, &quot;f&quot;, &quot;d&quot;], [&quot;a&quot;, &quot;e&quot;, &quot;g&quot; ], [&quot;a&quot;, &quot;e&quot;, &quot;h&quot;],
                        [&quot;a&quot;, &quot;i&quot;, &quot;j&quot;, &quot;b&quot;], [&quot;a&quot;, &quot;i&quot;, &quot;j&quot;, &quot;b&quot;, &quot;m&quot;],
                        [&quot;a&quot;, &quot;i&quot;, &quot;j&quot;, &quot;l&quot;, &quot;b&quot;, &quot;b&quot;, &quot;b&quot;, &quot;b&quot;, &quot;b&quot;, &quot;b&quot;, &quot;t&quot;, &quot;u&quot;, &quot;v&quot;, &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;b&quot;]],
                        FlatForestNode)
monotext(pretty_tree(rooter))
</pre></div>
</div>
<pre>a
├───── b
│      ├───── c
│      └───── d
├───── e
│      ├───── d_0
│      ├───── g
│      └───── h
├───── f
│      └───── d_1
└───── i
       └───── j
              ├───── b_0
              │      └───── m
              └───── l
                     └───── b_1
                            └───── b_2
                                   └───── b_3
                                          └───── b_4
                                                 └───── b_5
                                                        └───── b_6
                                                               └───── t
                                                                      └───── u
                                                                             └───── v
                                                                                    └───── w
                                                                                           └───── x
                                                                                                  └───── y
                                                                                                         └───── b_7
</pre><div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>from AlgoTree.utils import depth, path, ancestors, siblings, is_root
A = rooter.node(&quot;i&quot;)
pretty_tree(A)
print(depth(A.children[0]))
print([n.name for n in path(A.children[0].children[0])])
print([n.name for n in ancestors(A.children[0].children[0])])
print(siblings(A.children[0]))
print(is_root(A))
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">2</span>
<span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;j&#39;</span><span class="p">,</span> <span class="s1">&#39;b_0&#39;</span><span class="p">]</span>
<span class="p">[</span><span class="s1">&#39;j&#39;</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">]</span>
<span class="p">[]</span>
<span class="kc">False</span>
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>treenode = TreeNode(name=&quot;A&quot;)
TreeNode(name=&quot;B&quot;, parent=treenode)
C = TreeNode(name=&quot;C&quot;, parent=treenode)
TreeNode(name=&quot;D&quot;, parent=C)
TreeNode(name=&quot;E&quot;, parent=C)

monotext(pretty_tree(treenode))
</pre></div>
</div>
<pre>A
├───── B
└───── C
       ├───── D
       └───── E
</pre><div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>treenode_dict = {
    &quot;name&quot;: &quot;A&quot;,
    &quot;value&quot;: 1,
    &quot;children&quot;: [
        {&quot;name&quot;: &quot;B&quot;},
        {&quot;name&quot;: &quot;C&quot;, &quot;children&quot;: [
            {&quot;name&quot;: &quot;D&quot;},
            {&quot;name&quot;: &quot;E&quot;}
        ]}
    ]}

print(json.dumps(treenode_dict, indent=2))
print(json.dumps(treenode.to_dict(), indent=2))
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;A&quot;</span><span class="p">,</span>
  <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="s2">&quot;children&quot;</span><span class="p">:</span> <span class="p">[</span>
    <span class="p">{</span>
      <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;B&quot;</span>
    <span class="p">},</span>
    <span class="p">{</span>
      <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;C&quot;</span><span class="p">,</span>
      <span class="s2">&quot;children&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
          <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;D&quot;</span>
        <span class="p">},</span>
        <span class="p">{</span>
          <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;E&quot;</span>
        <span class="p">}</span>
      <span class="p">]</span>
    <span class="p">}</span>
  <span class="p">]</span>
<span class="p">}</span>
<span class="p">{</span>
  <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;A&quot;</span><span class="p">,</span>
  <span class="s2">&quot;payload&quot;</span><span class="p">:</span> <span class="n">null</span><span class="p">,</span>
  <span class="s2">&quot;children&quot;</span><span class="p">:</span> <span class="p">[</span>
    <span class="p">{</span>
      <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;B&quot;</span><span class="p">,</span>
      <span class="s2">&quot;payload&quot;</span><span class="p">:</span> <span class="n">null</span><span class="p">,</span>
      <span class="s2">&quot;children&quot;</span><span class="p">:</span> <span class="p">[]</span>
    <span class="p">},</span>
    <span class="p">{</span>
      <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;C&quot;</span><span class="p">,</span>
      <span class="s2">&quot;payload&quot;</span><span class="p">:</span> <span class="n">null</span><span class="p">,</span>
      <span class="s2">&quot;children&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
          <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;D&quot;</span><span class="p">,</span>
          <span class="s2">&quot;payload&quot;</span><span class="p">:</span> <span class="n">null</span><span class="p">,</span>
          <span class="s2">&quot;children&quot;</span><span class="p">:</span> <span class="p">[]</span>
        <span class="p">},</span>
        <span class="p">{</span>
          <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;E&quot;</span><span class="p">,</span>
          <span class="s2">&quot;payload&quot;</span><span class="p">:</span> <span class="n">null</span><span class="p">,</span>
          <span class="s2">&quot;children&quot;</span><span class="p">:</span> <span class="p">[]</span>
        <span class="p">}</span>
      <span class="p">]</span>
    <span class="p">}</span>
  <span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>treenode_from_dict = TreeNode.from_dict(treenode_dict)
monotext(pretty_tree(treenode_from_dict))
print(treenode_from_dict == treenode)
</pre></div>
</div>
<pre>A
├───── B
└───── C
       ├───── D
       └───── E
</pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kc">True</span>
</pre></div>
</div>
</section>
<section id="conclusion">
<h2>Conclusion<a class="headerlink" href="#conclusion" title="Link to this heading">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">FlatForest</span></code> class provides a powerful and flexible way to work
with tree-like and forest-like data structures using a flat dictionary
structure. It supports a wide range of operations, including node
manipulation, tree traversal, detachment, pruning, and conversion
between different tree representations.</p>
<p>Explore the <code class="docutils literal notranslate"><span class="pre">AlgoTree</span></code> package further to discover more features and
utilities for working with trees in Python.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">AlgoTree</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="flat_forest.html">FlatForest</a></li>
<li class="toctree-l1"><a class="reference internal" href="treenode.html">TreeNode</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">AlgoTree: Comprehensive Tutorial</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">FlatForest Notebook</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#creating-a-flatforest">Creating a <code class="docutils literal notranslate"><span class="pre">FlatForest</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#storing-and-transmitting-trees">Storing and Transmitting Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="#algorithm-examples">Algorithm Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="#conclusion">Conclusion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="expr_trees_nb.html">Expression Trees and Evaluation</a></li>
<li class="toctree-l1"><a class="reference internal" href="identity.html">Understanding Equality in Trees and Nodes</a></li>
<li class="toctree-l1"><a class="reference internal" href="jt.html">jt Command-Line Tool</a></li>
<li class="toctree-l1"><a class="reference internal" href="modules.html">AlgoTree</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="tutorial.html" title="previous chapter">AlgoTree: Comprehensive Tutorial</a></li>
      <li>Next: <a href="expr_trees_nb.html" title="next chapter">Expression Trees and Evaluation</a></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024, Alex Towell.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="_sources/flat_forest_nb.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>