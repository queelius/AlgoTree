<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AlgoTree.tree_transformer &#8212; AlgoTree 1.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=27fed22d" />
    <script src="../../_static/documentation_options.js?v=8d563738"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for AlgoTree.tree_transformer</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Tree transformation functionality.</span>

<span class="sd">This module provides transformation capabilities for tree structures,</span>
<span class="sd">allowing users to modify trees while preserving their structure (closed transformations).</span>
<span class="sd">Inspired by dotsuite&#39;s Shape pillar.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">copy</span><span class="w"> </span><span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.node</span><span class="w"> </span><span class="kn">import</span> <span class="n">Node</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.pattern_matcher</span><span class="w"> </span><span class="kn">import</span> <span class="n">dotmatch</span><span class="p">,</span> <span class="n">Pattern</span><span class="p">,</span> <span class="n">PatternMatcher</span>


<div class="viewcode-block" id="dotmod">
<a class="viewcode-back" href="../../AlgoTree.html#AlgoTree.tree_transformer.dotmod">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">dotmod</span><span class="p">(</span><span class="n">tree</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span> 
          <span class="n">transformations</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]],</span>
          <span class="n">in_place</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Node</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply closed tree-to-tree transformations using dot notation paths.</span>
<span class="sd">    </span>
<span class="sd">    This function modifies nodes in the tree based on dot notation paths,</span>
<span class="sd">    preserving the tree structure (closed transformation).</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        tree: Tree to transform</span>
<span class="sd">        transformations: Either:</span>
<span class="sd">            - Dict mapping dot paths to transformations</span>
<span class="sd">            - List of (dot_path, transformation) tuples</span>
<span class="sd">        in_place: If True, modify tree in place; otherwise create a copy</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        Transformed tree (same object if in_place=True, copy otherwise)</span>
<span class="sd">        </span>
<span class="sd">    Transformations can be:</span>
<span class="sd">        - Dict: Update node payload with dict contents</span>
<span class="sd">        - Callable: Apply function to node (receives node, returns dict to update payload)</span>
<span class="sd">        - String: Rename the node</span>
<span class="sd">        - None: Clear the payload (but keep the node)</span>
<span class="sd">        </span>
<span class="sd">    Examples:</span>
<span class="sd">        # Update specific nodes</span>
<span class="sd">        tree = dotmod(tree, {</span>
<span class="sd">            &quot;app.config&quot;: {&quot;version&quot;: &quot;2.0&quot;, &quot;debug&quot;: False},</span>
<span class="sd">            &quot;app.database&quot;: {&quot;host&quot;: &quot;localhost&quot;, &quot;port&quot;: 5432}</span>
<span class="sd">        })</span>
<span class="sd">        </span>
<span class="sd">        # Rename nodes</span>
<span class="sd">        tree = dotmod(tree, {</span>
<span class="sd">            &quot;app.oldname&quot;: &quot;newname&quot;</span>
<span class="sd">        })</span>
<span class="sd">        </span>
<span class="sd">        # Apply functions</span>
<span class="sd">        tree = dotmod(tree, {</span>
<span class="sd">            &quot;app.**.file&quot;: lambda n: {&quot;size&quot;: n.payload.get(&quot;size&quot;, 0) * 2}</span>
<span class="sd">        })</span>
<span class="sd">        </span>
<span class="sd">        # Multiple transformations to same path pattern</span>
<span class="sd">        tree = dotmod(tree, [</span>
<span class="sd">            (&quot;app.**.test_*&quot;, lambda n: {&quot;tested&quot;: True}),</span>
<span class="sd">            (&quot;app.**.test_*&quot;, lambda n: {&quot;priority&quot;: &quot;high&quot;})</span>
<span class="sd">        ])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Work on a copy unless in_place is True</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">in_place</span><span class="p">:</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
    
    <span class="c1"># Normalize transformations to list of tuples</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">transformations</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">transform_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">transformations</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">transform_list</span> <span class="o">=</span> <span class="n">transformations</span>
    
    <span class="c1"># Apply each transformation</span>
    <span class="k">for</span> <span class="n">dot_path</span><span class="p">,</span> <span class="n">transformation</span> <span class="ow">in</span> <span class="n">transform_list</span><span class="p">:</span>
        <span class="c1"># Find matching nodes</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="n">dotmatch</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">dot_path</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">transformation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Clear payload</span>
                <span class="n">node</span><span class="o">.</span><span class="n">payload</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">transformation</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="c1"># Rename node</span>
                <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">transformation</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">transformation</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="c1"># Update payload</span>
                <span class="n">node</span><span class="o">.</span><span class="n">payload</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">transformation</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">callable</span><span class="p">(</span><span class="n">transformation</span><span class="p">):</span>
                <span class="c1"># Apply function</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">transformation</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">result</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">payload</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">payload</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Transformation function must return str, dict, or None, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid transformation type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">transformation</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">tree</span></div>



<div class="viewcode-block" id="dotmap">
<a class="viewcode-back" href="../../AlgoTree.html#AlgoTree.tree_transformer.dotmap">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">dotmap</span><span class="p">(</span><span class="n">tree</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span>
          <span class="n">mapper</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Node</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]],</span>
          <span class="n">dot_path</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;**&quot;</span><span class="p">,</span>
          <span class="n">in_place</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Node</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Map a transformation function over nodes matching a pattern.</span>
<span class="sd">    </span>
<span class="sd">    This is a convenience function that applies the same transformation</span>
<span class="sd">    to all nodes matching a pattern.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        tree: Tree to transform</span>
<span class="sd">        mapper: Either:</span>
<span class="sd">            - Function that takes a node and returns dict to update payload</span>
<span class="sd">            - Dict mapping payload keys to transformation functions</span>
<span class="sd">        dot_path: Pattern to match nodes (default &quot;**&quot; for all nodes)</span>
<span class="sd">        in_place: If True, modify tree in place</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        Transformed tree</span>
<span class="sd">        </span>
<span class="sd">    Examples:</span>
<span class="sd">        # Double all sizes</span>
<span class="sd">        tree = dotmap(tree, lambda n: {&quot;size&quot;: n.payload.get(&quot;size&quot;, 0) * 2})</span>
<span class="sd">        </span>
<span class="sd">        # Transform specific fields</span>
<span class="sd">        tree = dotmap(tree, {</span>
<span class="sd">            &quot;size&quot;: lambda v: v * 2,</span>
<span class="sd">            &quot;name&quot;: lambda v: v.upper(),</span>
<span class="sd">            &quot;timestamp&quot;: lambda v: str(v)</span>
<span class="sd">        })</span>
<span class="sd">        </span>
<span class="sd">        # Apply only to specific nodes</span>
<span class="sd">        tree = dotmap(tree, </span>
<span class="sd">                     lambda n: {&quot;processed&quot;: True},</span>
<span class="sd">                     dot_path=&quot;app.data.**&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">in_place</span><span class="p">:</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
    
    <span class="n">matches</span> <span class="o">=</span> <span class="n">dotmatch</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">dot_path</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">mapper</span><span class="p">):</span>
            <span class="c1"># Single function mapper</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">mapper</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">node</span><span class="o">.</span><span class="n">payload</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="c1"># Dict of field mappers</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">mapper</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">payload</span><span class="p">:</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">payload</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">payload</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
    
    <span class="k">return</span> <span class="n">tree</span></div>



<div class="viewcode-block" id="dotprune">
<a class="viewcode-back" href="../../AlgoTree.html#AlgoTree.tree_transformer.dotprune">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">dotprune</span><span class="p">(</span><span class="n">tree</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span>
            <span class="n">condition</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Node</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]],</span>
            <span class="n">keep_structure</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">in_place</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Node</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Prune nodes from tree based on condition.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        tree: Tree to prune</span>
<span class="sd">        condition: Either:</span>
<span class="sd">            - Dot path pattern of nodes to remove</span>
<span class="sd">            - Predicate function (returns True for nodes to remove)</span>
<span class="sd">        keep_structure: If True, replace pruned nodes with empty placeholders</span>
<span class="sd">        in_place: If True, modify tree in place</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        Pruned tree</span>
<span class="sd">        </span>
<span class="sd">    Examples:</span>
<span class="sd">        # Remove all test files</span>
<span class="sd">        tree = dotprune(tree, &quot;**.test_*&quot;)</span>
<span class="sd">        </span>
<span class="sd">        # Remove empty directories</span>
<span class="sd">        tree = dotprune(tree, lambda n: n.payload.get(&quot;type&quot;) == &quot;dir&quot; and len(n.children) == 0)</span>
<span class="sd">        </span>
<span class="sd">        # Keep structure but clear nodes</span>
<span class="sd">        tree = dotprune(tree, &quot;**.deprecated&quot;, keep_structure=True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">in_place</span><span class="p">:</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
    
    <span class="c1"># Get nodes to prune</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="c1"># Dot path pattern</span>
        <span class="n">nodes_to_prune</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dotmatch</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">condition</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Predicate function</span>
        <span class="n">nodes_to_prune</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">traverse_preorder</span><span class="p">()</span> <span class="k">if</span> <span class="n">condition</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    
    <span class="c1"># Prune nodes</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">prune_recursive</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">parent</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Node</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Node</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes_to_prune</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">keep_structure</span><span class="p">:</span>
                <span class="c1"># Keep node but clear it</span>
                <span class="n">node</span><span class="o">.</span><span class="n">payload</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
                <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">node</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Remove node entirely</span>
                <span class="k">return</span> <span class="kc">None</span>
        
        <span class="c1"># Process children</span>
        <span class="n">new_children</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">):</span>
            <span class="n">pruned_child</span> <span class="o">=</span> <span class="n">prune_recursive</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pruned_child</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pruned_child</span><span class="p">)</span>
        
        <span class="n">node</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="n">new_children</span>
        
        <span class="c1"># Update parent references</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="n">child</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">node</span>
        
        <span class="k">return</span> <span class="n">node</span>
    
    <span class="n">result</span> <span class="o">=</span> <span class="n">prune_recursive</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span> <span class="k">if</span> <span class="n">result</span> <span class="k">else</span> <span class="n">Node</span><span class="p">(</span><span class="s2">&quot;empty&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="dotmerge">
<a class="viewcode-back" href="../../AlgoTree.html#AlgoTree.tree_transformer.dotmerge">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">dotmerge</span><span class="p">(</span><span class="n">tree1</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span>
            <span class="n">tree2</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span>
            <span class="n">merge_strategy</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;overlay&quot;</span><span class="p">,</span>
            <span class="n">conflict_resolver</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Node</span><span class="p">,</span> <span class="n">Node</span><span class="p">],</span> <span class="n">Node</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">in_place</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Node</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Merge two trees using various strategies.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        tree1: First tree (base)</span>
<span class="sd">        tree2: Second tree (overlay)</span>
<span class="sd">        merge_strategy: Strategy for merging:</span>
<span class="sd">            - &quot;overlay&quot;: tree2 values override tree1</span>
<span class="sd">            - &quot;underlay&quot;: tree1 values take precedence</span>
<span class="sd">            - &quot;combine&quot;: merge payloads, keeping both values</span>
<span class="sd">            - &quot;custom&quot;: use conflict_resolver function</span>
<span class="sd">        conflict_resolver: Function to resolve conflicts (for custom strategy)</span>
<span class="sd">        in_place: If True, modify tree1 in place</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        Merged tree</span>
<span class="sd">        </span>
<span class="sd">    Examples:</span>
<span class="sd">        # Simple overlay merge</span>
<span class="sd">        merged = dotmerge(tree1, tree2, &quot;overlay&quot;)</span>
<span class="sd">        </span>
<span class="sd">        # Custom conflict resolution</span>
<span class="sd">        def resolver(node1, node2):</span>
<span class="sd">            # Combine arrays, prefer tree2 for other values</span>
<span class="sd">            merged_payload = {}</span>
<span class="sd">            for key in set(node1.payload.keys()) | set(node2.payload.keys()):</span>
<span class="sd">                if key in node1.payload and key in node2.payload:</span>
<span class="sd">                    val1, val2 = node1.payload[key], node2.payload[key]</span>
<span class="sd">                    if isinstance(val1, list) and isinstance(val2, list):</span>
<span class="sd">                        merged_payload[key] = val1 + val2</span>
<span class="sd">                    else:</span>
<span class="sd">                        merged_payload[key] = val2</span>
<span class="sd">                elif key in node1.payload:</span>
<span class="sd">                    merged_payload[key] = node1.payload[key]</span>
<span class="sd">                else:</span>
<span class="sd">                    merged_payload[key] = node2.payload[key]</span>
<span class="sd">            return Node(node2.name, **merged_payload)</span>
<span class="sd">        </span>
<span class="sd">        merged = dotmerge(tree1, tree2, &quot;custom&quot;, conflict_resolver=resolver)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">in_place</span><span class="p">:</span>
        <span class="n">tree1</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">tree1</span><span class="p">)</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">merge_nodes</span><span class="p">(</span><span class="n">node1</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">node2</span><span class="p">:</span> <span class="n">Node</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Merge node2 into node1.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">merge_strategy</span> <span class="o">==</span> <span class="s2">&quot;overlay&quot;</span><span class="p">:</span>
            <span class="c1"># tree2 overrides tree1</span>
            <span class="n">node1</span><span class="o">.</span><span class="n">payload</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">node2</span><span class="o">.</span><span class="n">payload</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">merge_strategy</span> <span class="o">==</span> <span class="s2">&quot;underlay&quot;</span><span class="p">:</span>
            <span class="c1"># tree1 takes precedence</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">node2</span><span class="o">.</span><span class="n">payload</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">node1</span><span class="o">.</span><span class="n">payload</span><span class="p">:</span>
                    <span class="n">node1</span><span class="o">.</span><span class="n">payload</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">elif</span> <span class="n">merge_strategy</span> <span class="o">==</span> <span class="s2">&quot;combine&quot;</span><span class="p">:</span>
            <span class="c1"># Merge payloads, combining values</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">node2</span><span class="o">.</span><span class="n">payload</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">node1</span><span class="o">.</span><span class="n">payload</span><span class="p">:</span>
                    <span class="n">val1</span> <span class="o">=</span> <span class="n">node1</span><span class="o">.</span><span class="n">payload</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val1</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                        <span class="n">node1</span><span class="o">.</span><span class="n">payload</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val1</span> <span class="o">+</span> <span class="n">value</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val1</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                        <span class="n">val1</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Default to overlay for non-combinable types</span>
                        <span class="n">node1</span><span class="o">.</span><span class="n">payload</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">node1</span><span class="o">.</span><span class="n">payload</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">elif</span> <span class="n">merge_strategy</span> <span class="o">==</span> <span class="s2">&quot;custom&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">conflict_resolver</span><span class="p">:</span>
                <span class="n">merged</span> <span class="o">=</span> <span class="n">conflict_resolver</span><span class="p">(</span><span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">)</span>
                <span class="n">node1</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">merged</span><span class="o">.</span><span class="n">name</span>
                <span class="n">node1</span><span class="o">.</span><span class="n">payload</span> <span class="o">=</span> <span class="n">merged</span><span class="o">.</span><span class="n">payload</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;conflict_resolver required for custom merge strategy&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown merge strategy: </span><span class="si">{</span><span class="n">merge_strategy</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">merge_recursive</span><span class="p">(</span><span class="n">node1</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">node2</span><span class="p">:</span> <span class="n">Node</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Recursively merge trees.&quot;&quot;&quot;</span>
        <span class="c1"># Merge current nodes</span>
        <span class="n">merge_nodes</span><span class="p">(</span><span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">)</span>
        
        <span class="c1"># Build child map for node1</span>
        <span class="n">child_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">child</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">child</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node1</span><span class="o">.</span><span class="n">children</span><span class="p">}</span>
        
        <span class="c1"># Keep track of merged children</span>
        <span class="n">merged_children</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        
        <span class="c1"># Merge children</span>
        <span class="k">for</span> <span class="n">child2</span> <span class="ow">in</span> <span class="n">node2</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">child2</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">child_map</span><span class="p">:</span>
                <span class="c1"># Recursively merge matching children</span>
                <span class="n">merge_recursive</span><span class="p">(</span><span class="n">child_map</span><span class="p">[</span><span class="n">child2</span><span class="o">.</span><span class="n">name</span><span class="p">],</span> <span class="n">child2</span><span class="p">)</span>
                <span class="n">merged_children</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">child2</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Add new child from tree2</span>
                <span class="n">new_child</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">child2</span><span class="p">)</span>
                <span class="n">new_child</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">node1</span>
                <span class="n">node1</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_child</span><span class="p">)</span>
    
    <span class="c1"># Perform merge</span>
    <span class="n">merge_recursive</span><span class="p">(</span><span class="n">tree1</span><span class="p">,</span> <span class="n">tree2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tree1</span></div>



<div class="viewcode-block" id="dotgraft">
<a class="viewcode-back" href="../../AlgoTree.html#AlgoTree.tree_transformer.dotgraft">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">dotgraft</span><span class="p">(</span><span class="n">tree</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span>
            <span class="n">graft_point</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">subtree</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span>
            <span class="n">position</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;append&quot;</span><span class="p">,</span>
            <span class="n">in_place</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Node</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Graft a subtree onto a tree at specified point(s).</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        tree: Tree to graft onto</span>
<span class="sd">        graft_point: Dot path to graft point(s)</span>
<span class="sd">        subtree: Subtree to graft</span>
<span class="sd">        position: Where to add the subtree:</span>
<span class="sd">            - &quot;append&quot;: Add at end of children (default)</span>
<span class="sd">            - &quot;prepend&quot;: Add at beginning of children</span>
<span class="sd">            - int: Insert at specific index</span>
<span class="sd">            - &quot;replace&quot;: Replace existing children</span>
<span class="sd">        in_place: If True, modify tree in place</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        Tree with grafted subtree</span>
<span class="sd">        </span>
<span class="sd">    Examples:</span>
<span class="sd">        # Add new module to app</span>
<span class="sd">        new_module = Node(&quot;auth&quot;, type=&quot;module&quot;)</span>
<span class="sd">        tree = dotgraft(tree, &quot;app.modules&quot;, new_module)</span>
<span class="sd">        </span>
<span class="sd">        # Insert at specific position</span>
<span class="sd">        tree = dotgraft(tree, &quot;app.modules&quot;, new_module, position=0)</span>
<span class="sd">        </span>
<span class="sd">        # Replace children</span>
<span class="sd">        tree = dotgraft(tree, &quot;app.old_modules&quot;, new_modules, position=&quot;replace&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">in_place</span><span class="p">:</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
    
    <span class="n">graft_points</span> <span class="o">=</span> <span class="n">dotmatch</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">graft_point</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">graft_points</span><span class="p">:</span>
        <span class="c1"># Create a copy of the subtree for each graft point</span>
        <span class="n">graft_copy</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">subtree</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">position</span> <span class="o">==</span> <span class="s2">&quot;append&quot;</span><span class="p">:</span>
            <span class="c1"># Use proper method from Node class</span>
            <span class="n">point</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">graft_copy</span><span class="p">)</span>
            <span class="n">graft_copy</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">point</span>
        <span class="k">elif</span> <span class="n">position</span> <span class="o">==</span> <span class="s2">&quot;prepend&quot;</span><span class="p">:</span>
            <span class="n">point</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">graft_copy</span><span class="p">)</span>
            <span class="n">graft_copy</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">point</span>
        <span class="k">elif</span> <span class="n">position</span> <span class="o">==</span> <span class="s2">&quot;replace&quot;</span><span class="p">:</span>
            <span class="n">point</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="n">point</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">graft_copy</span><span class="p">)</span>
            <span class="n">graft_copy</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">point</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">point</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">graft_copy</span><span class="p">)</span>
            <span class="n">graft_copy</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">point</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid position: </span><span class="si">{</span><span class="n">position</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">tree</span></div>



<div class="viewcode-block" id="dotsplit">
<a class="viewcode-back" href="../../AlgoTree.html#AlgoTree.tree_transformer.dotsplit">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">dotsplit</span><span class="p">(</span><span class="n">tree</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span>
            <span class="n">split_point</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">include_point</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Node</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Node</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Split tree at specified point(s), extracting subtrees.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        tree: Tree to split</span>
<span class="sd">        split_point: Dot path to split point(s)</span>
<span class="sd">        include_point: If True, include split point in extracted subtrees</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        Tuple of (modified tree, list of extracted subtrees)</span>
<span class="sd">        </span>
<span class="sd">    Examples:</span>
<span class="sd">        # Extract all test modules</span>
<span class="sd">        tree, test_modules = dotsplit(tree, &quot;**.tests&quot;)</span>
<span class="sd">        </span>
<span class="sd">        # Extract but keep the container node</span>
<span class="sd">        tree, extracted = dotsplit(tree, &quot;app.deprecated&quot;, include_point=False)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tree_copy</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
    <span class="n">split_points</span> <span class="o">=</span> <span class="n">dotmatch</span><span class="p">(</span><span class="n">tree_copy</span><span class="p">,</span> <span class="n">split_point</span><span class="p">)</span>
    <span class="n">extracted</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1"># Process in reverse to avoid issues with modifying while iterating</span>
    <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">split_points</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">include_point</span><span class="p">:</span>
            <span class="c1"># Extract the entire node</span>
            <span class="n">extracted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">point</span><span class="p">))</span>
            
            <span class="c1"># Remove from parent</span>
            <span class="k">if</span> <span class="n">point</span><span class="o">.</span><span class="n">parent</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">point</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="k">pass</span>  <span class="c1"># Already removed</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Extract only children</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">children</span><span class="p">):</span>
                <span class="n">extracted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">child</span><span class="p">))</span>
            
            <span class="c1"># Clear children</span>
            <span class="n">point</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
    
    <span class="k">return</span> <span class="n">tree_copy</span><span class="p">,</span> <span class="n">extracted</span></div>



<div class="viewcode-block" id="dotflatten">
<a class="viewcode-back" href="../../AlgoTree.html#AlgoTree.tree_transformer.dotflatten">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">dotflatten</span><span class="p">(</span><span class="n">tree</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span>
              <span class="n">flatten_pattern</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;**&quot;</span><span class="p">,</span>
              <span class="n">max_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Node</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Flatten tree structure into a list of nodes.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        tree: Tree to flatten</span>
<span class="sd">        flatten_pattern: Pattern for nodes to include</span>
<span class="sd">        max_depth: Maximum depth to flatten to</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        List of nodes (flattened)</span>
<span class="sd">        </span>
<span class="sd">    Examples:</span>
<span class="sd">        # Get all nodes as flat list</span>
<span class="sd">        all_nodes = dotflatten(tree)</span>
<span class="sd">        </span>
<span class="sd">        # Get only file nodes</span>
<span class="sd">        files = dotflatten(tree, &quot;**[type=file]&quot;)</span>
<span class="sd">        </span>
<span class="sd">        # Flatten only top 3 levels</span>
<span class="sd">        top_nodes = dotflatten(tree, max_depth=3)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">matches</span> <span class="o">=</span> <span class="n">dotmatch</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">flatten_pattern</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">max_depth</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">matches</span> <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">level</span> <span class="o">&lt;=</span> <span class="n">max_depth</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">matches</span></div>



<div class="viewcode-block" id="dotreduce">
<a class="viewcode-back" href="../../AlgoTree.html#AlgoTree.tree_transformer.dotreduce">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">dotreduce</span><span class="p">(</span><span class="n">tree</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span>
             <span class="n">reducer</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Node</span><span class="p">],</span> <span class="n">Any</span><span class="p">],</span>
             <span class="n">initial</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
             <span class="n">traverse_pattern</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;**&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reduce tree to a single value using a reducer function.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        tree: Tree to reduce</span>
<span class="sd">        reducer: Function (accumulator, node) -&gt; new_accumulator</span>
<span class="sd">        initial: Initial value for accumulator</span>
<span class="sd">        traverse_pattern: Pattern for nodes to include in reduction</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        Reduced value</span>
<span class="sd">        </span>
<span class="sd">    Examples:</span>
<span class="sd">        # Sum all sizes</span>
<span class="sd">        total_size = dotreduce(tree, </span>
<span class="sd">                              lambda acc, n: acc + n.payload.get(&quot;size&quot;, 0),</span>
<span class="sd">                              initial=0)</span>
<span class="sd">        </span>
<span class="sd">        # Collect all names</span>
<span class="sd">        names = dotreduce(tree,</span>
<span class="sd">                         lambda acc, n: acc + [n.name],</span>
<span class="sd">                         initial=[])</span>
<span class="sd">        </span>
<span class="sd">        # Find maximum depth</span>
<span class="sd">        max_depth = dotreduce(tree,</span>
<span class="sd">                            lambda acc, n: max(acc, n.level),</span>
<span class="sd">                            initial=0)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="n">dotmatch</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">traverse_pattern</span><span class="p">)</span>
    <span class="n">accumulator</span> <span class="o">=</span> <span class="n">initial</span>
    
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
        <span class="n">accumulator</span> <span class="o">=</span> <span class="n">reducer</span><span class="p">(</span><span class="n">accumulator</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">accumulator</span></div>



<div class="viewcode-block" id="dotannotate">
<a class="viewcode-back" href="../../AlgoTree.html#AlgoTree.tree_transformer.dotannotate">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">dotannotate</span><span class="p">(</span><span class="n">tree</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span>
               <span class="n">annotator</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Node</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span>
               <span class="n">annotation_key</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;_annotation&quot;</span><span class="p">,</span>
               <span class="n">dot_path</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;**&quot;</span><span class="p">,</span>
               <span class="n">in_place</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Node</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Add annotations to nodes in the tree.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        tree: Tree to annotate</span>
<span class="sd">        annotator: Either:</span>
<span class="sd">            - Function that returns annotation dict for each node</span>
<span class="sd">            - Static annotation dict to add to all matching nodes</span>
<span class="sd">        annotation_key: Key to store annotations under in payload</span>
<span class="sd">        dot_path: Pattern for nodes to annotate</span>
<span class="sd">        in_place: If True, modify tree in place</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        Annotated tree</span>
<span class="sd">        </span>
<span class="sd">    Examples:</span>
<span class="sd">        # Add computed annotations</span>
<span class="sd">        tree = dotannotate(tree,</span>
<span class="sd">                          lambda n: {</span>
<span class="sd">                              &quot;depth&quot;: n.level,</span>
<span class="sd">                              &quot;has_children&quot;: len(n.children) &gt; 0,</span>
<span class="sd">                              &quot;path&quot;: &quot;.&quot;.join(p.name for p in n.get_path())</span>
<span class="sd">                          })</span>
<span class="sd">        </span>
<span class="sd">        # Add static annotations to specific nodes</span>
<span class="sd">        tree = dotannotate(tree,</span>
<span class="sd">                          {&quot;reviewed&quot;: True, &quot;version&quot;: &quot;1.0&quot;},</span>
<span class="sd">                          dot_path=&quot;**.critical_*&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">in_place</span><span class="p">:</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
    
    <span class="n">nodes</span> <span class="o">=</span> <span class="n">dotmatch</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">dot_path</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">annotator</span><span class="p">):</span>
            <span class="n">annotation</span> <span class="o">=</span> <span class="n">annotator</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">annotation</span> <span class="o">=</span> <span class="n">annotator</span>
        
        <span class="n">node</span><span class="o">.</span><span class="n">payload</span><span class="p">[</span><span class="n">annotation_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">annotation</span>
    
    <span class="k">return</span> <span class="n">tree</span></div>



<div class="viewcode-block" id="dotvalidate">
<a class="viewcode-back" href="../../AlgoTree.html#AlgoTree.tree_transformer.dotvalidate">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">dotvalidate</span><span class="p">(</span><span class="n">tree</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span>
               <span class="n">validator</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Node</span><span class="p">],</span> <span class="nb">bool</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span>
               <span class="n">dot_path</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;**&quot;</span><span class="p">,</span>
               <span class="n">raise_on_invalid</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Node</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Validate nodes in the tree against criteria.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        tree: Tree to validate</span>
<span class="sd">        validator: Either:</span>
<span class="sd">            - Predicate function returning True for valid nodes</span>
<span class="sd">            - Dict of required attributes and values</span>
<span class="sd">        dot_path: Pattern for nodes to validate</span>
<span class="sd">        raise_on_invalid: If True, raise exception on first invalid node</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        If raise_on_invalid=False: List of invalid nodes (empty if all valid)</span>
<span class="sd">        If raise_on_invalid=True: True if all valid (raises otherwise)</span>
<span class="sd">        </span>
<span class="sd">    Examples:</span>
<span class="sd">        # Validate with function</span>
<span class="sd">        dotvalidate(tree,</span>
<span class="sd">                   lambda n: n.payload.get(&quot;size&quot;, 0) &lt; 1000000,</span>
<span class="sd">                   dot_path=&quot;**[type=file]&quot;)</span>
<span class="sd">        </span>
<span class="sd">        # Validate required attributes</span>
<span class="sd">        dotvalidate(tree,</span>
<span class="sd">                   {&quot;type&quot;: &quot;file&quot;, &quot;tested&quot;: True},</span>
<span class="sd">                   dot_path=&quot;app.src.**&quot;)</span>
<span class="sd">        </span>
<span class="sd">        # Get list of invalid nodes</span>
<span class="sd">        invalid = dotvalidate(tree,</span>
<span class="sd">                            lambda n: len(n.name) &lt;= 255,</span>
<span class="sd">                            raise_on_invalid=False)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="n">dotmatch</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">dot_path</span><span class="p">)</span>
    <span class="n">invalid_nodes</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
        <span class="n">is_valid</span> <span class="o">=</span> <span class="kc">True</span>
        
        <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">validator</span><span class="p">):</span>
            <span class="n">is_valid</span> <span class="o">=</span> <span class="n">validator</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">validator</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">expected_value</span> <span class="ow">in</span> <span class="n">validator</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">payload</span> <span class="ow">or</span> <span class="n">node</span><span class="o">.</span><span class="n">payload</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">!=</span> <span class="n">expected_value</span><span class="p">:</span>
                    <span class="n">is_valid</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_valid</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">raise_on_invalid</span><span class="p">:</span>
                <span class="n">path</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">get_path</span><span class="p">())</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid node at path: </span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">invalid_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">raise_on_invalid</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="n">invalid_nodes</span></div>



<div class="viewcode-block" id="dotnormalize">
<a class="viewcode-back" href="../../AlgoTree.html#AlgoTree.tree_transformer.dotnormalize">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">dotnormalize</span><span class="p">(</span><span class="n">tree</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span>
                <span class="n">normalizer</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">normalize_payload</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                <span class="n">in_place</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Node</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Normalize node names and optionally payload keys.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        tree: Tree to normalize</span>
<span class="sd">        normalizer: Function to normalize names (default: lowercase + underscore)</span>
<span class="sd">        normalize_payload: If True, also normalize payload keys</span>
<span class="sd">        in_place: If True, modify tree in place</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        Normalized tree</span>
<span class="sd">        </span>
<span class="sd">    Examples:</span>
<span class="sd">        # Default normalization (lowercase, spaces to underscores)</span>
<span class="sd">        tree = dotnormalize(tree)</span>
<span class="sd">        </span>
<span class="sd">        # Custom normalization</span>
<span class="sd">        tree = dotnormalize(tree,</span>
<span class="sd">                          normalizer=lambda s: s.lower().replace(&quot;-&quot;, &quot;_&quot;))</span>
<span class="sd">        </span>
<span class="sd">        # Also normalize payload keys</span>
<span class="sd">        tree = dotnormalize(tree, normalize_payload=True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">in_place</span><span class="p">:</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">normalizer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">normalizer</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
            <span class="c1"># Default: lowercase, spaces/dashes to underscores</span>
            <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">traverse_preorder</span><span class="p">():</span>
        <span class="c1"># Normalize node name</span>
        <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">normalizer</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        
        <span class="c1"># Normalize payload keys if requested</span>
        <span class="k">if</span> <span class="n">normalize_payload</span><span class="p">:</span>
            <span class="n">new_payload</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">payload</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">new_key</span> <span class="o">=</span> <span class="n">normalizer</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="n">new_payload</span><span class="p">[</span><span class="n">new_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="n">node</span><span class="o">.</span><span class="n">payload</span> <span class="o">=</span> <span class="n">new_payload</span>
    
    <span class="k">return</span> <span class="n">tree</span></div>

</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">AlgoTree</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Getting Started:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fluent_api.html">AlgoTree Fluent API Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../pattern_matching.html">Pattern Matching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../transformations.html">Tree Transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial.html">AlgoTree: Comprehensive Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cookbook.html">AlgoTree Cookbook</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Traditional API:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../flat_forest.html">FlatForest</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../treenode.html">TreeNode</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../flat_forest_nb.html">FlatForest Notebook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../expr_trees_nb.html">Expression Trees and Evaluation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../identity.html">Understanding Equality in Trees and Nodes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tools &amp; Reference:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../jt.html">jt Command-Line Tool</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api_reference.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">AlgoTree</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024, Alex Towell.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
    </div>

    

    
  </body>
</html>