<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; AlgoTree 0.1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=12dfc556" />
    <script src="../_static/documentation_options.js?v=01f34227"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="AlgoTree" href="../modules.html" />
    <link rel="prev" title="&lt;no title&gt;" href="flat_forest_nb.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <dl>
<dt>{</dt><dd><dl>
<dt>“cells”: [</dt><dd><dl>
<dt>{</dt><dd><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“## Expression Trees and Evaluationn”,
“n”,
“We are going to explore the idea of expression trees and how they relate ton”,
“our tree structures, namely <cite>TreeNode</cite>, and to evaluate the expression treesn”,
“by rewriting the nodes in post-order traversal.n”,
“n”,
“First, let’s define our expression tree.”</p>
</div></blockquote>
<p>]</p>
</dd>
</dl>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: 1,
“metadata”: {},
“outputs”: [],
“source”: [</p>
<blockquote>
<div><p>“from AlgoTree.treenode import TreeNoden”,
“from copy import deepcopyn”,
“import jsonn”,
“n”,
“# Define the expression treen”,
“expr = TreeNode.from_dict(n”,
“    {n”,
“        &quot;value&quot;: &quot;+&quot;,n”,
“        &quot;type&quot;: &quot;op&quot;,n”,
“        &quot;children&quot;: [n”,
“            {n”,
“                &quot;value&quot;: &quot;max&quot;,n”,
“                &quot;type&quot;: &quot;op&quot;,n”,
“                &quot;children&quot;: [n”,
“                    {n”,
“                        &quot;value&quot;: &quot;+&quot;,n”,
“                        &quot;type&quot;: &quot;op&quot;,n”,
“                        &quot;children&quot;: [n”,
“                            {&quot;type&quot;: &quot;var&quot;, &quot;value&quot;: &quot;x&quot;},n”,
“                            {&quot;type&quot;: &quot;const&quot;, &quot;value&quot;: 1},n”,
“                        ],n”,
“                    },n”,
“                    {&quot;type&quot;: &quot;const&quot;, &quot;value&quot;: 0},n”,
“                ],n”,
“            },n”,
“            {n”,
“                &quot;type&quot;: &quot;op&quot;,n”,
“                &quot;value&quot;: &quot;+&quot;,n”,
“                &quot;children&quot;: [n”,
“                    {n”,
“                        &quot;type&quot;: &quot;op&quot;,n”,
“                        &quot;value&quot;: &quot;max&quot;,n”,
“                        &quot;children&quot;: [n”,
“                            {&quot;type&quot;: &quot;var&quot;, &quot;value&quot;: &quot;x&quot;},n”,
“                            {&quot;type&quot;: &quot;var&quot;, &quot;value&quot;: &quot;y&quot;},n”,
“                        ],n”,
“                    },n”,
“                    {&quot;type&quot;: &quot;const&quot;, &quot;value&quot;: 3},n”,
“                    {&quot;type&quot;: &quot;var&quot;, &quot;value&quot;: &quot;y&quot;},n”,
“                ],n”,
“            },n”,
“        ],n”,
“    }n”,
“)”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: 2,
“metadata”: {},
“outputs”: [</p>
<blockquote>
<div><dl>
<dt>{</dt><dd><p>“name”: “stdout”,
“output_type”: “stream”,
“text”: [</p>
<blockquote>
<div><p>“{n”,
“    &quot;name&quot;: &quot;0a5c451b-cad1-48e9-9852-aec46058acda&quot;,n”,
“    &quot;payload&quot;: {n”,
“        &quot;value&quot;: &quot;+&quot;,n”,
“        &quot;type&quot;: &quot;op&quot;n”,
“    },n”,
“    &quot;children&quot;: [n”,
“        {n”,
“            &quot;name&quot;: &quot;78baf6c2-afbd-4bb4-90a4-a08e5a3fc4e0&quot;,n”,
“            &quot;payload&quot;: {n”,
“                &quot;value&quot;: &quot;max&quot;,n”,
“                &quot;type&quot;: &quot;op&quot;n”,
“            },n”,
“            &quot;children&quot;: [n”,
“                {n”,
“                    &quot;name&quot;: &quot;fc106112-b614-467f-adff-c0c917ab03e5&quot;,n”,
“                    &quot;payload&quot;: {n”,
“                        &quot;value&quot;: &quot;+&quot;,n”,
“                        &quot;type&quot;: &quot;op&quot;n”,
“                    },n”,
“                    &quot;children&quot;: [n”,
“                        {n”,
“                            &quot;name&quot;: &quot;30a87f4c-b4be-4217-8a24-0f0d258b2a25&quot;,n”,
“                            &quot;payload&quot;: {n”,
“                                &quot;type&quot;: &quot;var&quot;,n”,
“                                &quot;value&quot;: &quot;x&quot;n”,
“                            },n”,
“                            &quot;children&quot;: []n”,
“                        },n”,
“                        {n”,
“                            &quot;name&quot;: &quot;41d8adc8-1f73-409a-ab68-ea98d53a1c56&quot;,n”,
“                            &quot;payload&quot;: {n”,
“                                &quot;type&quot;: &quot;const&quot;,n”,
“                                &quot;value&quot;: 1n”,
“                            },n”,
“                            &quot;children&quot;: []n”,
“                        }n”,
“                    ]n”,
“                },n”,
“                {n”,
“                    &quot;name&quot;: &quot;5a8df89c-c833-4aae-8749-5ce307424675&quot;,n”,
“                    &quot;payload&quot;: {n”,
“                        &quot;type&quot;: &quot;const&quot;,n”,
“                        &quot;value&quot;: 0n”,
“                    },n”,
“                    &quot;children&quot;: []n”,
“                }n”,
“            ]n”,
“        },n”,
“        {n”,
“            &quot;name&quot;: &quot;1d223ec4-9daf-45f4-b2a8-9db394571b83&quot;,n”,
“            &quot;payload&quot;: {n”,
“                &quot;type&quot;: &quot;op&quot;,n”,
“                &quot;value&quot;: &quot;+&quot;n”,
“            },n”,
“            &quot;children&quot;: [n”,
“                {n”,
“                    &quot;name&quot;: &quot;dde50326-3af8-4544-9551-9aa8123ac2bd&quot;,n”,
“                    &quot;payload&quot;: {n”,
“                        &quot;type&quot;: &quot;op&quot;,n”,
“                        &quot;value&quot;: &quot;max&quot;n”,
“                    },n”,
“                    &quot;children&quot;: [n”,
“                        {n”,
“                            &quot;name&quot;: &quot;f4057e80-3e19-477d-9b38-137b3a08d31e&quot;,n”,
“                            &quot;payload&quot;: {n”,
“                                &quot;type&quot;: &quot;var&quot;,n”,
“                                &quot;value&quot;: &quot;x&quot;n”,
“                            },n”,
“                            &quot;children&quot;: []n”,
“                        },n”,
“                        {n”,
“                            &quot;name&quot;: &quot;f633d8d3-2a2e-474c-a44d-5da441854dcb&quot;,n”,
“                            &quot;payload&quot;: {n”,
“                                &quot;type&quot;: &quot;var&quot;,n”,
“                                &quot;value&quot;: &quot;y&quot;n”,
“                            },n”,
“                            &quot;children&quot;: []n”,
“                        }n”,
“                    ]n”,
“                },n”,
“                {n”,
“                    &quot;name&quot;: &quot;1549bcb8-2ad7-45eb-a8f1-eef6aa53bbec&quot;,n”,
“                    &quot;payload&quot;: {n”,
“                        &quot;type&quot;: &quot;const&quot;,n”,
“                        &quot;value&quot;: 3n”,
“                    },n”,
“                    &quot;children&quot;: []n”,
“                },n”,
“                {n”,
“                    &quot;name&quot;: &quot;7dc9523b-2ab5-4fef-8424-5f189f2e85f2&quot;,n”,
“                    &quot;payload&quot;: {n”,
“                        &quot;type&quot;: &quot;var&quot;,n”,
“                        &quot;value&quot;: &quot;y&quot;n”,
“                    },n”,
“                    &quot;children&quot;: []n”,
“                }n”,
“            ]n”,
“        }n”,
“    ]n”,
“}n”</p>
</div></blockquote>
<p>]</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>],
“source”: [</p>
<blockquote>
<div><p>“# Print the expression tree in JSON formatn”,
“print(json.dumps(expr.to_dict(), indent=4))”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“### Visualizing the Tree Structuren”,
“n”,
“We can use the class <cite>PrettyTree</cite> (and a standalone <cite>pretty_tree</cite> function based onn”,
“that class) to visualize the tree structure in a more human-readable way.”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: 3,
“metadata”: {},
“outputs”: [],
“source”: [</p>
<blockquote>
<div><p>“from AlgoTree.tree_converter import TreeConvertern”,
“from AlgoTree.pretty_tree import pretty_tree”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: 4,
“metadata”: {},
“outputs”: [</p>
<blockquote>
<div><dl>
<dt>{</dt><dd><p>“name”: “stdout”,
“output_type”: “stream”,
“text”: [</p>
<blockquote>
<div><p>“+n”,
“├───── maxn”,
“│      ├───── +n”,
“│      │      ├───── xn”,
“│      │      └───── 1n”,
“│      └───── 0n”,
“└───── +n”,
“       ├───── maxn”,
“       │      ├───── xn”,
“       │      └───── yn”,
“       ├───── 3n”,
“       └───── yn”,
“n”</p>
</div></blockquote>
<p>]</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>],
“source”: [</p>
<blockquote>
<div><p>“print(pretty_tree(expr, node_name=lambda x: x.payload[&quot;value&quot;]))”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“### Post-order Traversaln”,
“n”,
“As a tree structure, <cite>TreeNode</cite> implements an interface that permitsn”,
“tree traversal algorithms like depth-first pre-order and post-order traversals.n”,
“n”,
“We are going to implement a simple post-order traversal algorithm to permitn”,
“computation of the expression tree we defined earlier, <cite>expr</cite>. We see thatn”,
“it contains three operator types, <cite>+</cite>, <cite>*</cite>, and <cite>max</cite>, as well as numbers and variables.n”,
“n”,
“We will provide a <strong>closure</strong> over all of these types so that when we evaluaten”,
“the expression in post-order, all of the types are defined for the operations.”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: 5,
“metadata”: {},
“outputs”: [],
“source”: [</p>
<blockquote>
<div><p>“def postorder(node, fn, ctx):n”,
“    &quot;&quot;&quot;n”,
“    Applies function <cite>fn</cite> to the nodes in the tree using post-order traversal.n”,
“    :param fn: Function to apply to each node. Should accept one argument: the node.n”,
“    :param ctx: Context passed to the function.n”,
“    :return: The tree with the function <cite>fn</cite> applied to its nodes.n”,
“    &quot;&quot;&quot;n”,
“    results = []n”,
“    for child in node.children:n”,
“        result = postorder(child, fn, ctx)n”,
“        if result is not None:n”,
“            results.append(result)n”,
“n”,
“    node.children = resultsn”,
“    return fn(node, ctx)”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“The function <cite>postorder</cite> takes a tree node <cite>node</cite>, a function <cite>fn</cite>, and a context <cite>ctx</cite>, and returns a rewritten tree.n”,
“n”,
“At each node, <cite>postorder</cite> recursively calls <cite>fn</cite> on its children before applying <cite>fn</cite> to the node itself. This is the essence of post-order traversal.n”,
“n”,
“Post-order is useful for problems where the children need to be processed before the node itself. For example, evaluating an expression tree, where typically the value of a node can only be computed after the values of its children are known.n”,
“n”,
“In contrast, pre-order traversal applies <cite>fn</cite> to the node before applying it to the children. Pre-order may be useful for tasks such as rewriting the tree in a different form, like algebraic simplification.”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“### Expression Tree Evaluatorn”,
“n”,
“We will now design a simple expression tree evaluator, <cite>Eval</cite>.”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: 6,
“metadata”: {},
“outputs”: [],
“source”: [</p>
<blockquote>
<div><p>“class Eval:n”,
“    &quot;&quot;&quot;n”,
“    An evaluator for expressions defined by operations on types, respectivelyn”,
“    defined by <cite>Eval.Op</cite> and <cite>Eval.Type</cite>. The operations are an”,
“    dictionary where the keys are the operation names and the values aren”,
“    functions that take a node and a context and return the value of then”,
“    operation in that context.n”,
“    &quot;&quot;&quot;n”,
“n”,
“    Op = {n”,
“        &quot;+&quot;: lambda x: sum(x),n”,
“        &quot;max&quot;: lambda x: max(x),n”,
“    }n”,
“n”,
“    Type = {n”,
“        &quot;const&quot;: lambda node, _: node.payload[&quot;value&quot;],n”,
“        &quot;var&quot;: lambda node, ctx: ctx[node.payload[&quot;value&quot;]],n”,
“        &quot;op&quot;: lambda node, _: Eval.Op[node.payload[&quot;value&quot;]](n”,
“            [c.payload[&quot;value&quot;] for c in node.children]n”,
“        ),n”,
“    }n”,
“n”,
“    def __init__(self, debug=True):n”,
“        &quot;&quot;&quot;n”,
“        :param debug: If True, print debug informationn”,
“        &quot;&quot;&quot;n”,
“        self.debug = debugn”,
“n”,
“    def __call__(self, expr, ctx):n”,
“        NodeType = type(expr)n”,
“        def _eval(node, ctx):n”,
“            expr_type = node.payload[&quot;type&quot;]n”,
“            value = Eval.Type[expr_type](node, ctx)n”,
“            result = NodeType(type=&quot;const&quot;, value=value)n”,
“            if self.debug:n”,
“                print(f&quot;Eval({node.payload}) -&gt; {result.payload}&quot;)n”,
“            return resultn”,
“n”,
“        return postorder(deepcopy(expr), _eval, ctx)”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“To evaluate an expression tree, we need the operations to be defined for alln”,
“of the types during post-order (bottom-up) traversal. We can define an”,
“closure over all of the types, and then use that closure to evaluate then”,
“expression tree.n”,
“n”,
“We call this closure a context. Normally, the operations and other thingsn”,
“are also defined in the closure, but for simplicity we will just define then”,
“operations and provide closures over the variables.”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: 7,
“metadata”: {},
“outputs”: [</p>
<blockquote>
<div><dl>
<dt>{</dt><dd><p>“name”: “stdout”,
“output_type”: “stream”,
“text”: [</p>
<blockquote>
<div><p>“Eval({‘type’: ‘var’, ‘value’: ‘x’}) -&gt; {‘type’: ‘const’, ‘value’: 1}n”,
“Eval({‘type’: ‘const’, ‘value’: 1}) -&gt; {‘type’: ‘const’, ‘value’: 1}n”,
“Eval({‘value’: ‘+’, ‘type’: ‘op’}) -&gt; {‘type’: ‘const’, ‘value’: 2}n”,
“Eval({‘type’: ‘const’, ‘value’: 0}) -&gt; {‘type’: ‘const’, ‘value’: 0}n”,
“Eval({‘value’: ‘max’, ‘type’: ‘op’}) -&gt; {‘type’: ‘const’, ‘value’: 2}n”,
“Eval({‘type’: ‘var’, ‘value’: ‘x’}) -&gt; {‘type’: ‘const’, ‘value’: 1}n”,
“Eval({‘type’: ‘var’, ‘value’: ‘y’}) -&gt; {‘type’: ‘const’, ‘value’: 2}n”,
“Eval({‘type’: ‘op’, ‘value’: ‘max’}) -&gt; {‘type’: ‘const’, ‘value’: 2}n”,
“Eval({‘type’: ‘const’, ‘value’: 3}) -&gt; {‘type’: ‘const’, ‘value’: 3}n”,
“Eval({‘type’: ‘var’, ‘value’: ‘y’}) -&gt; {‘type’: ‘const’, ‘value’: 2}n”,
“Eval({‘type’: ‘op’, ‘value’: ‘+’}) -&gt; {‘type’: ‘const’, ‘value’: 7}n”,
“Eval({‘value’: ‘+’, ‘type’: ‘op’}) -&gt; {‘type’: ‘const’, ‘value’: 9}n”</p>
</div></blockquote>
<p>]</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>],
“source”: [</p>
<blockquote>
<div><p>“# Define the context with variable valuesn”,
“ctx = {&quot;x&quot;: 1, &quot;y&quot;: 2, &quot;z&quot;: 3}n”,
“n”,
“# Evaluate the expression tree with the contextn”,
“result = Eval(debug=True)(expr, ctx)”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“Let’s print the final result of the evaluation of the expression tree.”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: 8,
“metadata”: {},
“outputs”: [</p>
<blockquote>
<div><dl>
<dt>{</dt><dd><p>“name”: “stdout”,
“output_type”: “stream”,
“text”: [</p>
<blockquote>
<div><p>“{‘type’: ‘const’, ‘value’: 9}n”</p>
</div></blockquote>
<p>]</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>],
“source”: [</p>
<blockquote>
<div><p>“# Print the result of the evaluationn”,
“print(result.payload)”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“## Self-Evaluating Treesn”,
“n”,
“We see that we get the expected result, <cite>9</cite>. Note that it is still a tree, butn”,
“it has been transformed into a so-called self-evaluating tree expression,n”,
“which in this case is a single node with no children.n”,
“n”,
“We can evaluate it again, and we see that it cannot be rewritten further. Wen”,
“call this state a <strong>normal form</strong>. Essentially, we can think of then”,
“tree as a program that computes a value, and the normal form is the result ofn”,
“running the program.”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: 9,
“metadata”: {},
“outputs”: [],
“source”: [</p>
<blockquote>
<div><p>“# Ensure the evaluated result is in its normal formn”,
“assert Eval(debug=False)(result, ctx).payload == result.payload”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“### Converting to FlatForestn”,
“n”,
“Let’s convert the tree to a <cite>FlatForest</cite> and perform the same evaluation.”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: 10,
“metadata”: {},
“outputs”: [</p>
<blockquote>
<div><dl>
<dt>{</dt><dd><p>“name”: “stdout”,
“output_type”: “stream”,
“text”: [</p>
<blockquote>
<div><p>“+n”,
“├───── maxn”,
“│      ├───── +n”,
“│      │      ├───── xn”,
“│      │      └───── 1n”,
“│      └───── 0n”,
“└───── +n”,
“       ├───── maxn”,
“       │      ├───── xn”,
“       │      └───── yn”,
“       ├───── 3n”,
“       └───── yn”,
“n”</p>
</div></blockquote>
<p>]</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>],
“source”: [</p>
<blockquote>
<div><p>“from AlgoTree.flat_forest_node import FlatForestNoden”,
“from AlgoTree.flat_forest import FlatForestn”,
“flat_expr = TreeConverter.convert(source=expr, target_type=FlatForestNode, extract=lambda x: x.payload)n”,
“print(pretty_tree(flat_expr, node_name=lambda x: x.payload[&quot;value&quot;]))n”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“Evaluate the flat forest expression”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: 11,
“metadata”: {},
“outputs”: [</p>
<blockquote>
<div><dl>
<dt>{</dt><dd><p>“name”: “stdout”,
“output_type”: “stream”,
“text”: [</p>
<blockquote>
<div><p>“{‘type’: ‘const’, ‘value’: 9}n”</p>
</div></blockquote>
<p>]</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>],
“source”: [</p>
<blockquote>
<div><p>“result = Eval(False)(flat_expr, ctx)n”,
“print(result.payload)”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“The <cite>FlatForest</cite> structure is a different kind of structure that is moren”,
“convenient for relatively flatter data, like conversation logs. It is a forestn”,
“structure that is flattened into a dictionary of key-value pairs, where then”,
“value is also a dictionary. This value dictionary optionally contains the parentn”,
“key, and if not then it is a root node. If more than one root node is present,n”,
“then it is a forest, but by default it exposes a single root node (preferred root)n”,
“for convenience, which is by default the first root node encountered.”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“### Handling Undefined Variablesn”,
“n”,
“What happens when we change the context so that not every variable is defined?”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: 12,
“metadata”: {},
“outputs”: [</p>
<blockquote>
<div><dl>
<dt>{</dt><dd><p>“name”: “stdout”,
“output_type”: “stream”,
“text”: [</p>
<blockquote>
<div><p>“Eval({‘type’: ‘var’, ‘value’: ‘x’}) -&gt; {‘type’: ‘const’, ‘value’: 1}n”,
“Eval({‘type’: ‘const’, ‘value’: 1}) -&gt; {‘type’: ‘const’, ‘value’: 1}n”,
“Eval({‘value’: ‘+’, ‘type’: ‘op’}) -&gt; {‘type’: ‘const’, ‘value’: 2}n”,
“Eval({‘type’: ‘const’, ‘value’: 0}) -&gt; {‘type’: ‘const’, ‘value’: 0}n”,
“Eval({‘value’: ‘max’, ‘type’: ‘op’}) -&gt; {‘type’: ‘const’, ‘value’: 2}n”,
“Eval({‘type’: ‘var’, ‘value’: ‘x’}) -&gt; {‘type’: ‘const’, ‘value’: 1}n”,
“Error: ‘y’n”</p>
</div></blockquote>
<p>]</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>],
“source”: [</p>
<blockquote>
<div><p>“# Define an incomplete context with missing variable valuesn”,
“open_ctx = {n”,
“    &quot;x&quot;: 1,n”,
“    # ‘y’: 2,  # ‘y’ is not defined in this contextn”,
“    &quot;z&quot;: 3,n”,
“}n”,
“n”,
“# Try evaluating the expression tree with the incomplete contextn”,
“try:n”,
“    Eval(debug=True)(expr, open_ctx)n”,
“except KeyError as e:n”,
“    print(f&quot;Error: {e}&quot;)”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“We see that we get an error. Our operations in <cite>Eval.Op</cite> are not defined overn”,
“undefined variables.n”,
“n”,
“We would run into a similar problem if we used pre-order traversal instead of post-order. In pre-order traversal, we would try to evaluate the parent node (say, an operation) before we had evaluated its children, which would result in an error. Ourn”,
“defined operations only work over numbers (type <cite>const</cite>), so we need ton”,
“evaluate the non-<cite>const</cite> expressions first in order for our operations to ben”,
“defined for them.”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“### Post-order vs. Pre-order Traversaln”,
“n”,
“Post-order traversal is good for things like evaluating expressions, where youn”,
“need to evaluate the children before you can evaluate the parent.n”,
“n”,
“Pre-order traversal is good for things like rewriting trees from the top down,n”,
“but your rewrite rules need to be defined in terms of sub-expression trees.n”,
“So, for example, you might have a complex expression and seek to rewrite itn”,
“into a simpler form. This is an example of a <strong>rewrite system</strong>. A rewrite systemn”,
“is a set of rules that transform expressions into other expressions. Forn”,
“instance, suppose that we add a <cite>0</cite> to a variable <cite>x</cite> in the expression tree.n”,
“We know that <cite>x + 0</cite> is the same as <cite>x</cite>, so we could add a rewrite rule that maps then”,
“sub-tree <cite>(+ x 0)</cite> to <cite>x</cite>. We could add many rewrite rules to implement, forn”,
“instance, algebraic simplification (<cite>simplify</cite>), or implement a compilern”,
“(<cite>compile</cite>) that translates the tree into a different form that could ben”,
“evaluated by a different set of rewrite rules. Or, the compiler could be ann”,
“optimizing compiler that rewrites the tree into a form that is more efficientn”,
“to evaluate, like replacing a multiplication by a power of two with a shiftn”,
“or getting rid of no-op operations like adding zero.”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“## Alternative Way To Construct Expression Treesn”,
“n”,
“We imported from a <cite>dict</cite> (or JSON) representation of the expression tree. Thisn”,
“is a common way to construct trees from data, and it is also a common way ton”,
“serialize trees to disk or to send them over the network.n”,
“n”,
“Howerver, we can also construct the tree directly using the <cite>TreeNode</cite> class.”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: 13,
“metadata”: {},
“outputs”: [],
“source”: [</p>
<blockquote>
<div><p>“root = TreeNode(name=&quot;+&quot;, value=&quot;+&quot;, type=&quot;op&quot;)n”,
“root_1 = TreeNode(name=&quot;max&quot;, value=&quot;max&quot;, type=&quot;op&quot;, parent=root)n”,
“root_2 = TreeNode(name=&quot;+&quot;, value=&quot;+&quot;, type=&quot;op&quot;, parent=root)n”,
“root_1_1 = TreeNode(name=&quot;+&quot;, value=&quot;+&quot;, type=&quot;op&quot;, parent=root_1)n”,
“root_1_1_1 = TreeNode(name=&quot;var&quot;, value=&quot;x&quot;, type=&quot;var&quot;, parent=root_1_1)n”,
“root_1_1_2 = TreeNode(name=&quot;const&quot;, value=1, type=&quot;const&quot;, parent=root_1_1)n”,
“root_2_1 = TreeNode(name=&quot;max&quot;, value=&quot;max&quot;, type=&quot;op&quot;, parent=root_2)n”,
“root_2_1_1 = TreeNode(name=&quot;var&quot;, value=&quot;x&quot;, type=&quot;var&quot;, parent=root_2_1)n”,
“root_2_1_2 = TreeNode(name=&quot;var&quot;, value=&quot;y&quot;, type=&quot;var&quot;, parent=root_2_1)n”,
“root_2_2 = TreeNode(name=&quot;const&quot;, value=3, type=&quot;const&quot;, parent=root_2)n”,
“root_2_3 = TreeNode(name=&quot;var&quot;, value=&quot;y&quot;, type=&quot;var&quot;, parent=root_2)”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“Let’s evaluate this tree to see if it gives the same result as the previousn”,
“expression tree.”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: 14,
“metadata”: {},
“outputs”: [</p>
<blockquote>
<div><dl>
<dt>{</dt><dd><p>“name”: “stdout”,
“output_type”: “stream”,
“text”: [</p>
<blockquote>
<div><p>“{‘type’: ‘const’, ‘value’: 9}n”</p>
</div></blockquote>
<p>]</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>],
“source”: [</p>
<blockquote>
<div><p>“result = Eval(False)(flat_expr, ctx)n”,
“print(result.payload)”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“## Conclusionn”,
“n”,
“We have explored the idea of expression trees and how they relate to our treen”,
“structures, namely <cite>TreeNode</cite> and <cite>FlatForestNode</cite>, and how to evaluate then”,
“expression trees by rewriting the nodes in post-order traversal.n”,
“n”,
“The <cite>TreeNode</cite> structure is a general-purpose tree structure that is fast andn”,
“efficient for these kinds of operations. The <cite>FlatForestNode</cite> structure isn”,
“a more specialized structure that is more convenient for relatively flattern”,
“data, like conversation logs.”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>],
“metadata”: {</p>
<blockquote>
<div><dl class="simple">
<dt>“kernelspec”: {</dt><dd><p>“display_name”: “env”,
“language”: “python”,
“name”: “python3”</p>
</dd>
</dl>
<p>},
“language_info”: {</p>
<blockquote>
<div><dl class="simple">
<dt>“codemirror_mode”: {</dt><dd><p>“name”: “ipython”,
“version”: 3</p>
</dd>
</dl>
<p>},
“file_extension”: “.py”,
“mimetype”: “text/x-python”,
“name”: “python”,
“nbconvert_exporter”: “python”,
“pygments_lexer”: “ipython3”,
“version”: “3.12.3”</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>},
“nbformat”: 4,
“nbformat_minor”: 2</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">AlgoTree</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../flat_forest.html">FlatForest</a></li>
<li class="toctree-l1"><a class="reference internal" href="../treenode.html">TreeNode</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial.html">AlgoTree: Comprehensive Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules.html">AlgoTree</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="flat_forest_nb.html" title="previous chapter">&lt;no title&gt;</a></li>
      <li>Next: <a href="../modules.html" title="next chapter">AlgoTree</a></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024, Alex Towell.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.3.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
      |
      <a href="../_sources/notebooks/expr_trees_nb.ipynb.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>